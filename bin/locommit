#!/bin/bash

PositionalArgs=()
while [[ $# -gt 0 ]]; do
    case $1 in
        --no-git)     Options_NoGit="yes"; shift;;
        -b|--branch)  Options_Branch="$2"; shift; shift;;
        --file)       Options_File="$2"; shift; shift;;
        --zip-commit) Options_ZipCommit="yes"; shift;;
        -*) echo "Unknown option $1"; exit 1;;
        *) PositionalArgs+=("$1"); shift;;
    esac
done
set -- "${PositionalArgs[@]}"  #// set $1, $2, ...
unset PositionalArgs

function  Main() {
    local  subCommand="$1"
    AssertInstalled  "git"
    if [ "${subCommand}" == "" ]; then
        LocalCommit
    elif [ "${subCommand:0:1}" == "-" ]; then
        LocalCommit  "$@"
    elif [ "${subCommand}" == "clone" ]; then
        shift
        Clone  "$@"
    elif [ "${subCommand}" == "status" ]; then
        shift
        LocalCommit  "$@"
    elif [ "${subCommand}" == "push" ]; then
        shift
        Push  "$@"
    elif [ "${subCommand}" == "pull" ]; then
        shift
        Pull  "$@"
    elif [ "${subCommand}" == "pull-base" ]; then
        shift
        PullBase  "$@"
    elif [ "${subCommand}" == "init-bare-push" ]; then
        shift
        InitBarePush  "$@"
    else
        Error  "ERROR: Unknown sub command \"${subCommand}\""
    fi
}

function  LocalCommit() {
    local  option="$1"
    local  noGitOption="${False}"
    if [ "${option}" == "--no-git"  -o  "${Options_NoGit}" != "" ]; then
        noGitOption="${True}"
    elif [ "${option}" != "" ]; then
        Error  "Unknown option \"${option}\""
    fi
    local  currentFolder="${PWD}"
    local  gitWorkingRootPath="$( GetGitWorkingRootPath  || echo "(ERROR)" )"
    local  outputFolderName=""
    ErrorIfLastIs  "${gitWorkingRootPath}"  "(ERROR)"
    if [ -e ".commit"  -a  -e ".commit.zip" ]; then
        Error  "ERROR: Remove \".commit\" or \".commit.zip\"."
    fi
    if [ -e ".commit.zip" ]; then
        echo  'Unzipped ".commit.zip" to make ".commit" folder.'
        unzip  ".commit.zip"  >  /dev/null
    fi
    if [ ! -e ".commit" ]; then
        outputFolderName=".commit"
        if [ "${currentFolder}" == "${gitWorkingRootPath}"  -a  "${noGitOption}" == "${False}" ]; then
            Error  "locommit command cannot create new \".commit\" folder where \".git\" folder exists. You can specify --no-git option."
        fi
    else
        outputFolderName=".commit_new"
    fi
    local  workingFolderPath="${PWD}"
    local  rsyncUsed="${False}"
    if IsWindowsFolder  "${workingFolderPath}"; then
        if [ "${LOCOMMIT_TMP}" != "" ]; then
            echo  "Using LOCOMMIT_TMP (${LOCOMMIT_TMP}) because \"${workingFolderPath}\" is Windows shared folder."
            RsyncToTemporary  "${workingFolderPath}"  "${LOCOMMIT_TMP}"
            workingFolderPath="${LOCOMMIT_TMP}${workingFolderPath}"
            pushd  "${workingFolderPath}" > /dev/null  ||  Error
            rsyncUsed="${True}"
        else
            echo  "LOCOMMIT_TMP environment variable is not set though \"${workingFolderPath}\" is Windows shared folder."
        fi
    fi

    #// Copy files by "git checkout-index"
    if [ "${gitWorkingRootPath}" == "" ]; then
        DeleteFolder  "${outputFolderName}"
        if [ "${noGitOption}" == "${False}" ]; then
            echo  "Added .git folder and first commit."
            GitInit
            git add "."  > /dev/null  2>&1
            git commit  -m "locommit) Created local working directory"  > /dev/null  2>&1
        else
            GitInit
            git add "."  > /dev/null  2>&1
        fi
        mkdir  "${outputFolderName}"

        git checkout-index -fau --prefix="${outputFolderName}/"
        if [ "${noGitOption}" == "${True}" ]; then
            DeleteFolder  ".git"  #// Temporary .git
            if [ "${gitIgnoreExists}" == "${False}" ]; then
                rm  ".gitignore"
                rm  "${outputFolderName}/.gitignore"
            fi
        fi
    else
        DeleteFolder  "${outputFolderName}"
        if [ "${currentFolder}" == "${gitWorkingRootPath}" ]; then
            mkdir -p  "${outputFolderName}"
            mv  ".git"  "${outputFolderName}/.commit_.git"
            GitInit  #// Temporary .git
            git add  "."  #// checkout new contents

            git checkout-index -fau --prefix="${outputFolderName}/"
            DeleteFolder  ".git"  #// Temporary .git
            mv  "${outputFolderName}/.commit_.git"  ".git"
        else  #// There is ".git" folder in parent folder.
            local  gitIgnoreExists="${True}"
            if [ ! -e ".gitignore"  -a  -e "${gitWorkingRootPath}/.gitignore" ]; then
                gitIgnoreExists="${False}"
                cat  "${gitWorkingRootPath}/.gitignore"  |  grep -v  "^/"  >  ".gitignore"
            fi
            if [ "${noGitOption}" == "${False}" ]; then
                echo  "Added .git folder and first commit."
            fi
            GitInit
            git add  "."
            git commit -m  "locommit) First commit"

            git checkout-index -fau --prefix="${outputFolderName}/"
            if [ "${noGitOption}" == "${True}" ]; then
                DeleteFolder  ".git"  #// Temporary .git
                if [ "${gitIgnoreExists}" == "${False}" ]; then
                    rm  ".gitignore"
                    rm  "${outputFolderName}/.gitignore"
                fi
            fi
        fi
    fi

    #// Set read only
    if [ "${noGitOption}" == "${False}" ]; then
        SetReadOnly  "${outputFolderName}"
    fi

    #// Show conflict file names
    pushd  "${outputFolderName}" > /dev/null  ||  Error

    local  conflictOutput=$( grep -rn  "^<<<<<<<"  "."  |  sed  "s/\\(:[0-9][0-9]*:\\)\\([^ ]\\)/\\1 \\2/"  || echo "(ERROR)" )
    popd > /dev/null
    ErrorIfLastIs  "${conflictOutput}"  "(ERROR)"
    if [ "${conflictOutput}" != "" ]; then
        echo  "CONFLICT:"
        EchoWithIndent  "${conflictOutput}"  "    "
    fi

    #// Show different file names
    if [ "${outputFolderName}" == ".commit" ]; then
        echo  'Created new ".commit" folder.'
        if [ "${noGitOption}" == "${False}" ]; then
            echo  'This will be treated as base commit.'
        fi
    fi

    if [ "${outputFolderName}" == ".commit_new" ]; then
        local  diff_output="$( diff -qr  ".commit"  ".commit_new" )"

        if [ "${diff_output}" == "" ]; then
            DeleteFolder  ".commit_new"
            echo  'Deleted ".commit_new" folder.'
            echo  'SAME as ".commit" folder.'
        else
            echo  'Created new ".commit_new" folder.'
            echo  'Changes for .commit:'
            EchoWithIndent  "${diff_output}"  "    "
        fi
    fi

    if [ "${gitWorkingRootPath}" == ""  -a  "${noGitOption}" == "${True}" ]; then
        DeleteFolder  ".git"
    fi
    if [ -e ".commit.zip" ]; then
        echo  'Deleted ".commit" folder extracted from ".commit.zip" file.'
        DeleteFolder  ".commit"
    fi
    if [ "${rsyncUsed}" == "${True}" ]; then
        RsyncFromTemporary  "${workingFolderPath}"  "${LOCOMMIT_TMP}"
        popd  > /dev/null
    fi
}

function  Clone() {
    local  repositoryFolderPath="$1"
    local  destinationFolderPath="$2"
    if [ "$1" == ""  -o  "$2" == "" ]; then
        Error  "ERROR: locommit clone __RepositoryFolderPath__ __DestinationFolderPath__"
    fi
    if [ "${Options_File}" != "" ]; then
        CloneFile  "$@"
        return $?
    fi
    pushd  "${repositoryFolderPath}"  > /dev/null
    if [ -e ".git" ]; then
        CheckIfGitResetState
        if AllFilesAreGitAdd; then
            local  allFilesAreGitAdd="${True}"
        else
            local  allFilesAreGitAdd="${False}"
        fi
    fi
    popd  > /dev/null
    repositoryFolderPath=$( ResolvePath "${repositoryFolderPath}" )
    repositoryFolderPath="$( CutLastOf "${repositoryFolderPath}" "/"  || echo "(ERROR)" )"
    AssertExist  "${repositoryFolderPath}"
    if [ -e "${destinationFolderPath}" ]; then
        Error  "fatal: destination path '${destinationFolderPath}' already exists."  128
    fi

    mkdir -p  "${destinationFolderPath}"
    destinationFolderPath="$( readlink -f "${destinationFolderPath}" )"
    repositoryFolderPath="$( readlink -f "${repositoryFolderPath}" )"
    local  rsyncRepositoryUsed="${False}"
    if IsWindowsFolder  "${repositoryFolderPath}"; then
        if [ "${LOCOMMIT_TMP}" != "" ]; then
            echo  "Using LOCOMMIT_TMP (${LOCOMMIT_TMP}) because \"${repositoryFolderPath}\" is Windows shared folder."
            RsyncToTemporary  "${repositoryFolderPath}"  "${LOCOMMIT_TMP}"
            repositoryFolderPath="${LOCOMMIT_TMP}${repositoryFolderPath}"
            rsyncRepositoryUsed="${True}"
        else
            echo  "LOCOMMIT_TMP environment variable is not set though \"${repositoryFolderPath}\" is Windows shared folder."
        fi
    fi
    local  rsyncDestinationUsed="${False}"
    if IsWindowsFolder  "${destinationFolderPath}"; then
        if [ "${LOCOMMIT_TMP}" != "" ]; then
            echo  "Using LOCOMMIT_TMP (${LOCOMMIT_TMP}) because \"${destinationFolderPath}\" is Windows shared folder."
            RsyncToTemporary  "${destinationFolderPath}"  "${LOCOMMIT_TMP}"
            destinationFolderPath="${LOCOMMIT_TMP}${destinationFolderPath}"
            rsyncDestinationUsed="${True}"
        else
            echo  "LOCOMMIT_TMP environment variable is not set though \"${destinationFolderPath}\" is Windows shared folder."
        fi
    fi

    pushd  "${repositoryFolderPath}"  > /dev/null
    if [ -e ".git" ]; then
        local  hasDotGit="${True}"
    else
        local  hasDotGit="${False}"
        GitInit
    fi
    git reset "."  > /dev/null
    git rm -r --cached  "."  > /dev/null  2>&1
    git add "."  > /dev/null  2>&1

    git checkout-index -fau --prefix="${destinationFolderPath}/.commit/"
    if [ "${allFilesAreGitAdd}" == "${False}" ]; then
        git reset "."  > /dev/null
    fi
    if [ ! -e "${destinationFolderPath}/.commit/" ]; then  #// Error
        rm -rf  "${destinationFolderPath}"
        if [ "${rsyncDestinationUsed}" == "${True}" ]; then
            destinationFolderPath="${destinationFolderPath:${#LOCOMMIT_TMP}}"
            rm -rf  "${destinationFolderPath}"
        fi
        if [ "${hasDotGit}" == "${False}" ]; then
            local  message1="\".git\" folder was created and "
        else
            local  message1=""
        fi
        Error  "ERROR: ${message1}\"git checkout-index -fau\" command did not copy any files in \"${PWD}\""
    fi
    CopyFolder  "${destinationFolderPath}/.commit"  "${destinationFolderPath}"
    SetReadOnly  "${destinationFolderPath}/.commit"
    if [ "${hasDotGit}" == "${False}" ]; then
        DeleteFolder  "${repositoryFolderPath}/.git"
    fi
    if [ "${Options_ZipCommit}" == "" ]; then
        echo  'Created new ".commit" folder.'
    else
        pushd "${destinationFolderPath}" > /dev/null
        SetNotReadOnly  ".commit"
        zip -r  ".commit.zip"  ".commit"  >  /dev/null  ||  Error
        DeleteFolder  ".commit"
        popd > /dev/null
        echo  'Created new ".commit.zip" file.'
    fi

    cd  "${destinationFolderPath}"
    if [ ! -e ".gitignore" ]; then
        echo  ".commit"    > ".gitignore"
        echo  ".commit_*" >> ".gitignore"
        echo  ".commit.*" >> ".gitignore"
    fi
    GitInit
    git add "."  > /dev/null  2>&1
    git commit -m  "locommit) First commit"  > /dev/null
    popd  > /dev/null

    if [ "${rsyncRepositoryUsed}" == "${True}" ]; then
        RsyncFromTemporary  "${repositoryFolderPath}"  "${LOCOMMIT_TMP}"
    fi
    if [ "${rsyncDestinationUsed}" == "${True}" ]; then
        RsyncFromTemporary  "${destinationFolderPath}"  "${LOCOMMIT_TMP}"
    fi
}

function  CloneFile() {
    local  repositoryFolderPath="$1"
    local  destinationFolderPath="$2"
    local  fileRelativePath="${Options_File}"
    local  fileName="${fileRelativePath##*/}"
    if [ "$1" == ""  -o  "$2" == "" ]; then
        Error  "ERROR: locommit clone __RepositoryFolderPath__ __DestinationFolderPath__"
    fi
    repositoryFolderPath="$( CutLastOf "${repositoryFolderPath}" "/"  || echo "(ERROR)" )"
    destinationFolderPath="$( CutLastOf "${destinationFolderPath}" "/"  || echo "(ERROR)" )"
    AssertExist  "${repositoryFolderPath}"
    if [ -e "${destinationFolderPath}/${fileRelativePath}" ]; then
        Error  "fatal: destination path '${destinationFolderPath}/${fileRelativePath}' already exists."  128
    fi
    local  destinationFilePath="${destinationFolderPath}/${fileRelativePath}"
    local  destinationFileParent="${destinationFilePath%/*}"
    mkdir -p  "${destinationFileParent}/.commit"

    cp -ap  "${repositoryFolderPath}/${fileRelativePath}"  "${destinationFilePath}"
    cp -ap  "${repositoryFolderPath}/${fileRelativePath}"  "${destinationFileParent}/.commit"
    SetReadOnly  "${destinationFileParent}/.commit/${fileName}"
}

function  Push() {
    if [ "${Options_File}" == "" ]; then
        PushFolder  "$@"
    else
        PushFile  "$@"
    fi
}

function  PushFile() {
    local  repositoryFolderPath="$1"
    local  fileRelativePath="${Options_File}"
    local  fileName="${fileRelativePath##*/}"
    local  repositoryFolderPath=$( ResolvePath "${repositoryFolderPath}" )
    repositoryFolderPath="$( CutLastOf "${repositoryFolderPath}" "/"  || echo "(ERROR)" )"
    ErrorIfLastIs  "${repositoryFolderPath}"  "(ERROR)"
    if [ "${repositoryFolderPath}" == "" ]; then
        Error  "Not specified destination repository folder. Run the command: locommit push __RepositoryFolderPath__"
    fi
    test  "${repositoryFolderPath}" != "/dev/null"  ||  Error
    local  filePathInRepository="${repositoryFolderPath}/${fileRelativePath}"
    local  parentInRepository="${filePathInRepository%/*}"
    mkdir -p  "${parentInRepository}"

    echo  "Copied \"${fileRelativePath}\" file to \"${repositoryFolderPath}\" folder"
    cp -ap  "${fileRelativePath}"  "${filePathInRepository}"
    SetNotReadOnly  ".commit/${fileRelativePath}"

    cp -ap  "${fileRelativePath}"  ".commit/${fileRelativePath}"
    SetReadOnly  ".commit/${fileRelativePath}"

    local  deletingFiles=(
        ".commit_new/${fileRelativePath}"
        ".commit_ours/${fileRelativePath}"
        ".commit_theirs/${fileRelativePath}"
        ".commit_old_ours/${fileRelativePath}"
        ".commit_old_base/${fileRelativePath}"
    )
    for filePath in "${deletingFiles[@]}" ;do
        SetNotReadOnly  "${filePath}"
        rm -f  "${filePath}"
    done
}

function  PushFolder() {
    local  repositoryFolderPath="$1"
    local  repositoryFolderPath=$( ResolvePath "${repositoryFolderPath}" )
    repositoryFolderPath="$( CutLastOf "${repositoryFolderPath}" "/"  || echo "(ERROR)" )"
    ErrorIfLastIs  "${repositoryFolderPath}"  "(ERROR)"
    if [ "${repositoryFolderPath}" == "" ]; then
        Error  "Not specified destination repository folder. Run the command: locommit push __RepositoryFolderPath__"
    fi
    if [ -e ".commit.zip" ]; then
        DeleteFolder  ".commit"
        unzip  ".commit.zip"  >  /dev/null
    fi
    if [ ! -e ".commit" ]; then
        PushWithoutLocalCommit  "$@"
        return
    fi
    AssertExist  "${repositoryFolderPath}"
    AssertExist  ".commit"
    local  source=".commit_new"
    if [ ! -e ".commit_new" ]; then
        source=".commit"
    fi

    #// (.commit case) Check no update
    if [ "${source}" == ".commit" ]; then
        if [ -e ".commit.zip" ]; then
            DeleteFolder  ".commit"
        fi

        LocalCommit > /dev/null
        if [ -e ".commit_new" ]; then
            DeleteFolder  ".commit_new"
            Error  "push command requires .commit_new folder, if update file exists. Run locommit command."
        fi
        if [ -e ".commit.zip" ]; then
            unzip  ".commit.zip"  >  /dev/null
        fi
    fi

    #// Copy files and disable read only
    if [ "${repositoryFolderPath}" != "/dev/null" ]; then

        #// Check "repositoryFolderPath". It prevents to delete "source" folder.
        local  sourceFullPath="$( readlink -f "${source}" )/"
        local  repositoryFullPath="$( readlink -f "${repositoryFolderPath}" )/"
        if StartsWith  "${sourceFullPath}"  "${repositoryFullPath}"; then
            Error  "push 先は カレント フォルダー の外に指定する必要があります"  #// "Push target must be out of current folder"
        fi

        #// Copy files and disable read only
        echo  "Copied files and disabled read only to \"${repositoryFolderPath}\" folder"
        CopyFolder  "${source}"  "${repositoryFolderPath}"  "--exclude=./.git"
        SetNotReadOnly  "${repositoryFolderPath}"

        #// Delete deleted files
        if [ "${source}" == ".commit_new" ]; then
            local  oldFileNames="$( find ".commit"     -type f  |  sed -E 's/$/:/' )"
            local  newFileNames="$( find ".commit_new" -type f  |  sed -E 's/$/:/'  |  sed -E 's/^.commit_new/.commit/' )"
            local  deletingFileNames="$( CutCommonPartLines  "${oldFileNames}"  "${newFileNames}" )"
            deletingFileNames="$( echo "${deletingFileNames}"  |  sed -E 's|^.commit/||'  |  sed -E 's|:$||' )"
            if [ "${deletingFileNames}" != "" ]; then
                echo  "Deleting some files in \"${repositoryFolderPath}\" folder"
                local  oldIFS="$IFS"
                IFS=$'\n'
                for fileName in ${deletingFileNames}; do
                    SetNotReadOnly  "${repositoryFolderPath}/${fileName}"
                    rm -f  "${repositoryFolderPath}/${fileName}"
                done
                IFS="$oldIFS"
            fi
        fi
    fi
    DeleteFolder ".commit_ours"
    DeleteFolder ".commit_theirs"
    DeleteFolder ".commit_old_ours"
    DeleteFolder ".commit_old_base"

    local  workingFolderPath="${PWD}"
    local  rsyncUsed="${False}"
    if IsWindowsFolder  "${workingFolderPath}"; then
        if [ "${LOCOMMIT_TMP}" != "" ]; then
            echo  "Using LOCOMMIT_TMP (${LOCOMMIT_TMP}) because \"${workingFolderPath}\" is Windows shared folder."
            RsyncToTemporary  "${workingFolderPath}"  "${LOCOMMIT_TMP}"
            workingFolderPath="${LOCOMMIT_TMP}${workingFolderPath}"
            pushd  "${workingFolderPath}" > /dev/null  ||  Error
            local  rsyncUsed="${True}"
        else
            echo  "LOCOMMIT_TMP environment variable is not set though \"${workingFolderPath}\" is Windows shared folder."
        fi
    fi

    #// (.commit_new case) Update .commit folder
    if [ "${source}" == ".commit_new" ]; then
        if [ ! -e ".commit.zip" ]; then
            echo  'Moved ".commit_new" to ".commit" folder'
        else
            echo  'Compress and moved ".commit_new" to ".commit.zip" file'
        fi
        DeleteFolder  ".commit"

        mv  ".commit_new"  ".commit"
        if [ -e ".commit.zip" ]; then
            if IsWindowsFolder  "${workingFolderPath}"; then
                sleep 1s
            fi
            SetNotReadOnly  ".commit"
            zip -r  ".commit.zip"  ".commit"  >  /dev/null  ||  Error
            DeleteFolder  ".commit"
        fi
    fi

    #// git commit
    if [ -e ".git" ]; then
        if [ "$(git status --short)" != "" ]; then
            git add "."
            git commit  -m "locommit push) Updated." > /dev/null
        fi
    fi
    if [ "${rsyncUsed}" == "${True}" ]; then
        RsyncFromTemporary  "${workingFolderPath}"  "${LOCOMMIT_TMP}"
        popd  > /dev/null
    fi
}

function  PushWithoutLocalCommit() {
    local  outputFolderPath="$1"
    AssertExist  "${outputFolderPath}"
    AssertNotExist  ".commit"
    if [ ! -e ".git" ]; then
        Error  "locommit push command requires \".commit\" or \".git\" folder."
    fi
    DeleteFolder  "${outputFolderPath}"
    mkdir  "${outputFolderPath}"

    git checkout-index -fau --prefix="${outputFolderPath}/"
}

function  Pull() {
    #   *   4 (pulled)
    #   |\    <-- Pull command
    #   | * 3 _repository
    #   * | 2 .commit_new
    #   |/
    #   *   1 .commit
    if [ "${Options_File}" == "" ]; then
        PullSub  "$1"  --pull
    else
        PullFile  "$1"  --pull
    fi
}

function  PullSub() {
    local  repositoryFolderPath_="$1"
    local  option="$2"  #// "--pull" or "--pull-base"
    local  baseFolderRelativePath="$3"  #// This is enabled if option == "--pull-base"
    local  repositoryFolderPath_=$( ResolvePath "${repositoryFolderPath_}"  || echo "(ERROR)" )
    local  repositoryFolderPath="$( CutLastOf "${repositoryFolderPath_}" "/"  || echo "(ERROR)" )"
    ErrorIfLastIs  "${repositoryFolderPath_}"  "(ERROR)"
    ErrorIfLastIs  "${repositoryFolderPath}"  "(ERROR)"
    if [ "${repositoryFolderPath}" == "" ]; then
        Error  "Not specified repository folder.  Expected command: locommit pull __RepositoryFolderPath__"
    fi
    if [ "${baseFolderRelativePath:0:2}" == ".." ]; then  Error;  fi
    if [ "${baseFolderRelativePath:0:1}" == "/" ]; then  Error;  fi
    AssertExist  "${repositoryFolderPath}"
    repositoryFolderPath="$( readlink -f "${repositoryFolderPath}" )"
    if [ -e ".commit"  -a  -e ".commit.zip" ]; then
        Error  "ERROR: Remove \".commit\" or \".commit.zip\"."
    fi
    if [ ! -e ".commit.zip" ]; then
        AssertExist  ".commit"
    fi
    local  source=".commit_new"
    if [ ! -e ".commit_new" ]; then
        source=".commit"
    fi
    local  workingFolderPath="${PWD}"
    local  rsyncWorkingUsed="${False}"
    if IsWindowsFolder  "${workingFolderPath}"; then
        if [ "${LOCOMMIT_TMP}" != "" ]; then
            echo  "Using LOCOMMIT_TMP (${LOCOMMIT_TMP}) because \"${workingFolderPath}\" is Windows shared folder."
            RsyncToTemporary  "${workingFolderPath}"  "${LOCOMMIT_TMP}"
            workingFolderPath="${LOCOMMIT_TMP}${workingFolderPath}"
            pushd  "${workingFolderPath}" > /dev/null  ||  Error
            local  rsyncWorkingUsed="${True}"
        else
            echo  "LOCOMMIT_TMP environment variable is not set though \"${workingFolderPath}\" is Windows shared folder."
        fi
    fi
    if IsWindowsFolder  "${repositoryFolderPath}"; then
        if [ "${LOCOMMIT_TMP}" != "" ]; then
            echo  "Using LOCOMMIT_TMP (${LOCOMMIT_TMP}) because \"${repositoryFolderPath}\" is Windows shared folder."
            RsyncToTemporary  "${repositoryFolderPath}"  "${LOCOMMIT_TMP}"
            repositoryFolderPath="${LOCOMMIT_TMP}${repositoryFolderPath}"
        else
            echo  "LOCOMMIT_TMP environment variable is not set though \"${repositoryFolderPath}\" is Windows shared folder."
        fi
    fi

    #// Create ".commit_new" folder
    if [ "${source}" == ".commit" ]; then
        echo  'Created new ".commit_new" folder.'
        LocalCommit > /dev/null
        if [ -e ".commit_new" ]; then
            source=".commit_new"
        fi
    fi
    if [ -e ".commit.zip" ]; then
        echo  'Unzipped ".commit.zip" to make ".commit" folder.'
        unzip  ".commit.zip"  >  /dev/null
    fi
    if [ "${option}" == "--pull-base" ]; then
        DeleteFolder  "${source}/${baseFolderRelativePath}"
    fi

    #// Create ".commit_theirs" folder
    #// ".commit_theirs" is a copy of a folder in related repository at
    #// "repositoryFolderPath", except for the files covered by ".gitignore".
        AssertNotExist  "${repositoryFolderPath}/.commit_new"
        local  thereIsRepositoryCommit=${False}
        if [ -e "${repositoryFolderPath}/.commit" ]; then
            thereIsRepositoryCommit=${True}
        fi

        #// Create ".commit_theirs" folder
        DeleteFolder  ".commit_theirs"
        pushd  "${repositoryFolderPath}" > /dev/null

        LocalCommit --no-git > /dev/null
        popd > /dev/null
        if [ -e "${repositoryFolderPath}/.commit_new" ]; then
            mv  "${repositoryFolderPath}/.commit_new"  ".commit_theirs"
        else
            if [ "${thereIsRepositoryCommit}" == "${True}" ]; then
                CopyFolder  "${repositoryFolderPath}/.commit"  ".commit_theirs"
            else
                mv  "${repositoryFolderPath}/.commit"  ".commit_theirs"
            fi
        fi
        echo  'Copied a repository folder to ".commit_theirs" folder'

    #// Create ".commit_ours" folder
    if [ "${source}" == ".commit_new" ]; then
        DeleteFolder  ".commit_ours"
        mv  ".commit_new"  ".commit_ours"
        echo  'Renamed ".commit_new" folder to ".commit_ours" folder'
    else
        DeleteFolder    ".commit_ours"
        mkdir -p  ".commit_ours"
        ls -a ".commit" | grep -v  -e "^\.$"  -e "^\.\.$" | xargs  -I {} \
            cp -Rap  ".commit/{}"  ".commit_ours"
        DeleteFolder  ".commit_ours/.git"
        echo  'Copied ".commit" folder to ".commit_ours" folder'
    fi

    #// Add to stage in parent .git, if the parent .git includes current folder.
    local  parentDotGit="${False}"
    if [ ! -e ".git" ]; then
        parentDotGit="${True}"
        git add  "."  > /dev/null
    fi

    #// Make a ".git" folder that has "commit_reposiroty" branch
    echo  'Pull from ".commit_theirs" folder'
    local  currentBranch=$( git rev-parse --abbrev-ref HEAD  || echo "(ERROR)" )
    ErrorIfLastIs  "${currentBranch}"  "(ERROR)"

    #// Check ".commit" folder
    pushd  ".commit" > /dev/null
        if [ -e "../.git" ]; then
            mv  "../.git"  "."
            local  clean="${False}"
            if [ "$(git status --short)" == "" ]; then
                clean="${True}"
            fi
            if [ "${clean}" == "${False}" ]; then
                git add "."
                git commit -m "Reverted to .commit contents."  > /dev/null
                if [ "${option}" == "--pull" ]; then
                    echo  "Added a commit of \".commit\" contents."
                else
                    echo  "Added a commit of old \"${baseFolderRelativePath}\" contents (pull base version)."
                fi
                if [ "$(git status --short)" != "" ]; then
                    mv  ".git"  ".."
                    popd  > /dev/null
                    Error  ".commit folder is not git clean status"
                fi
            fi

            mkdir -p  "../.commit_theirs/.git"
            ls -a ".git" | grep -v  -e "^\.$"  -e "^\.\.$" | xargs  -I {} \
                cp -Rap  ".git/{}"  "../.commit_theirs/.git"
            mv  ".git"  ".."
        else
            GitInit
            git add  "."
            git commit  -m "locommit pull) Created a common commit." > /dev/null  #// Ignore this command errors
            currentBranch=$( git rev-parse --abbrev-ref HEAD  || echo "(ERROR)" )
            ErrorIfLastIs  "${currentBranch}"  "(ERROR)"
            mkdir -p  "../.commit_theirs"
            mv  ".git"  "../.commit_theirs"
        fi

    #// Make the repository branch
        cd  "../.commit_theirs"
        local  reposirotyBranchExists="${False}"
        git branch | grep "__locommit_commit_theirs" > /dev/null 2>&1  &&  reposirotyBranchExists="${True}"
        if [ "${reposirotyBranchExists}" == "${True}" ]; then
            git branch -D "__locommit_commit_theirs" > /dev/null 2>&1  ||  Error
        fi
        git checkout -b "__locommit_commit_theirs" > /dev/null 2>&1  ||  Error
        if [ "${option}" == "--pull-base" ]; then
            DeleteFolder  "${baseFolderRelativePath}"
        fi
        git add "." > /dev/null
        git commit  -m "locommit pull) commit_theirs" > /dev/null  #// Ignore this command errors
        local  oldCommitID=$( git rev-parse --short "${currentBranch}"  || echo "(ERROR)" )
        local  theirsCommitID=$( git rev-parse --short __locommit_commit_theirs  || echo "(ERROR)" )
        ErrorIfLastIs  "${oldCommitID}"  "(ERROR)"
        ErrorIfLastIs  "${theirsCommitID}"  "(ERROR)"
        mkdir -p "../.commit_temporary"
        mv  ".git"  "../.commit_temporary"

    #// Change current branch
        cd  "../.commit_temporary"
        git checkout "${currentBranch}" > /dev/null 2>&1  ||  Error
        DeleteFolder  "../.git"
        mv  ".git"  ".."
        cd  ".."
        mv  ".commit_temporary"  ".commit_temporary_deleting"
        DeleteFolder  ".commit_temporary_deleting"  #// This command is sometimes rejected because device or resource busy
    popd > /dev/null

    #// Merge
    #// source: ".commit_theirs" folder
    #// destination: current folder
    if [ "${source}" == ".commit_new" ]; then
        git add "."
        git commit  -m "locommit pull) commit_ours" > /dev/null
    fi
    if [ "${theirsCommitID}" != "${oldCommitID}" ]; then

        local  mergeLog="$( git merge  "__locommit_commit_theirs" --no-edit  2>&1  ||  echo "(ERROR)" )"
        if echo "${mergeLog}" | grep "Abort."; then
            echo "${mergeLog}"
            Error  "failed: git merge .commit_theirs"
        fi
    fi
    if [ "${parentDotGit}" == "${True}" ]; then
        DeleteFolder  ".git"
    else
        git branch -D  "__locommit_commit_theirs"  > /dev/null
    fi

    #// Restore .git folder and stage before pull files
    if [ "${theirsCommitID}" != "${oldCommitID}" ]; then
        if [ -e ".commit/.git" ]; then
            cd  ".commit_ours"
            mv  "../.commit/.git"  "."
            git add  "."
            cd  ".."
            mv  ".commit_ours/.git"  "."
        fi

        #// Diff
        local  diff_output="$( diff -qr  ".commit"  ".commit_theirs" )"
        if [ "${option}" == "--pull-base" ]; then
            echo  'Renamed ".commit" folder to ".commit_old_base" folder (pull base version)'
            echo  'Renamed ".commit_theirs" folder to new '"\"${baseFolderPath}\" folder (pull base version)"
            diff_output="$( echo "${diff_output}"  |
                sed -E 's|.commit/|.commit_old_base/|g'  |
                sed -E 's|.commit_theirs/|new _base/|g'  )"
        fi
        ErrorIfLastIs  "${diff_output}"  "(ERROR)"
        if [ "${option}" == "--pull" ]; then
            echo  'Updated files by this merge from ".commit_theirs" folder (pull base version):'
        else
            echo  "Updated files by this merge from new \"${baseFolderPath}\" folder:"
        fi
        EchoWithIndent  "${diff_output}"  "    "
        if [ -e ".commit.zip" ]; then
            echo  'Deleted ".commit" folder extracted from ".commit.zip" file.'
            DeleteFolder  ".commit"
        fi
    else
        echo  'Renamed ".commit_ours" folder to ".commit_new" folder'
        echo  'Deleted ".commit_theirs" folder'
        if [ -e ".commit/.git" ]; then
            mv  ".commit/.git"  "."
        fi
        mv  ".commit_ours"  ".commit_new"
        DeleteFolder  ".commit_theirs"
        if [ -e ".commit.zip" ]; then
            echo  'Deleted ".commit" folder extracted from ".commit.zip" file.'
            DeleteFolder  ".commit"
        fi
        echo  'Pull command did not change any files.'
    fi
    if [ "${rsyncWorkingUsed}" == "${True}" ]; then
        RsyncFromTemporary  "${workingFolderPath}"  "${LOCOMMIT_TMP}"
        popd  > /dev/null
    fi
}

function  PullBase() {
    #   *   5 (pulled)
    #   |\    <-- PullBase command
    #   | * 4 _repository
    #   * | 3 .commit_new
    #   * | 2 .commit
    #   |/
    #   *   1 _base
    local  baseFolderPath_=$( ResolvePath "$1"  || echo "(ERROR)" )
    local  repositoryFolderPath_="$2"
    local  baseFolderPath="$( CutLastOf "${baseFolderPath_}" "/"  || echo "(ERROR)" )"
    local  repositoryFolderPath_=$( ResolvePath "${repositoryFolderPath_}"  || echo "(ERROR)" )
    local  repositoryFolderPath="$( CutLastOf "${repositoryFolderPath_}" "/"  || echo "(ERROR)" )"
    ErrorIfLastIs  "${baseFolderPath_}"  "(ERROR)"
    ErrorIfLastIs  "${baseFolderPath}"  "(ERROR)"
    ErrorIfLastIs  "${repositoryFolderPath_}"  "(ERROR)"
    ErrorIfLastIs  "${repositoryFolderPath}"  "(ERROR)"
    if [ "${baseFolderPath}" == "" ]; then
        Error  "Not specified base folder.  Expected command: locommit pull-base __BaseFolderRelativePath__ __RepositoryFolderPath__"
    fi
    if [ "${repositoryFolderPath}" == "" ]; then
        Error  "Not specified repository folder.  Expected command: locommit pull-base __BaseFolderRelativePath__ __RepositoryFolderPath__"
    fi
    if [ "${baseFolderPath:0:2}" == ".."  -o  "${baseFolderPath:0:1}" == "/" ]; then
        Error  "BaseFolderPath must be in current folder."
    fi
    AssertExist  "${baseFolderPath}"
    AssertExist  "${repositoryFolderPath}"

    echo  'Renamed ".commit" folder to ".commit_this" folder'
    echo  "Renamed \"${baseFolderPath}\""' folder to ".commit" folder'
    StartInTemporary  "LOCOMMIT_TMP"  "${LOCOMMIT_TMP}"
    mv  ".commit"  ".commit_this"  ||  Error
    mv  "${baseFolderPath}"  ".commit"  ||  Error
    EndInTemporary  "LOCOMMIT_TMP"  "${LOCOMMIT_TMP}"s

    #// Pull command
    echo  "Start pull command (of pull base version)"
    shift

    PullSub  "$1"  --pull-base  "${baseFolderPath}"
    echo  "End pull command (of pull base version)"

    #// After pull command
    StartInTemporary  "LOCOMMIT_TMP"  "${LOCOMMIT_TMP}"
    if [ -e ".commit_theirs" ]; then
        #// There is echo command in PullSub
        mv  ".commit"  ".commit_old_base"  ||  Error
        mv  ".commit_theirs"  "${baseFolderPath}"  ||  Error
    else
        echo  'Renamed ".commit" folder to new '"\"${baseFolderPath}\" folder"
        mv  ".commit"  "${baseFolderPath}"  ||  Error
    fi
    if [ -e ".commit_ours" ]; then
        echo  'Renamed ".commit_ours" folder to ".commit_old_ours" folder'
        mv  ".commit_ours"  ".commit_old_ours"  ||  Error
    fi
    echo  'Renamed ".commit_this" folder to ".commit" folder'
    mv  ".commit_this"  ".commit"  ||  Error
    EndInTemporary  "LOCOMMIT_TMP"  "${LOCOMMIT_TMP}"
}

function  PullFile() {
    local  repositoryFolderPath_="$1"
    local  option="$2"  #// "--pull" or "--pull-base"
    local  baseFolderRelativePath="$3"  #// This is enabled if option == "--pull-base"
    local  fileRelativePath="${Options_File}"
    local  fileName="${fileRelativePath##*/}"
    local  repositoryFolderPath_=$( ResolvePath "${repositoryFolderPath_}"  || echo "(ERROR)" )
    local  repositoryFolderPath="$( CutLastOf "${repositoryFolderPath_}" "/"  || echo "(ERROR)" )"
    ErrorIfLastIs  "${repositoryFolderPath_}"  "(ERROR)"
    ErrorIfLastIs  "${repositoryFolderPath}"  "(ERROR)"
    if [ "${repositoryFolderPath}" == "" ]; then
        Error  "Not specified repository folder.  Expected command: locommit pull __RepositoryFolderPath__"
    fi
    test -f "${repositoryFolderPath}/${fileRelativePath}"  ||  Error
    if [ "${baseFolderRelativePath:0:2}" == ".." ]; then  Error;  fi
    if [ "${baseFolderRelativePath:0:1}" == "/" ]; then  Error;  fi
    AssertExist  "${repositoryFolderPath}"
    repositoryFolderPath="$( readlink -f "${repositoryFolderPath}" )"
    AssertExist  ".commit"

    if diff  "${repositoryFolderPath}/${fileRelativePath}"  ".commit/${fileRelativePath}" > /dev/null; then  #// If a file in repository does not changed
        echo  "Pull command did not change any file."
        return
    fi
    if diff  "${fileRelativePath}"  ".commit/${fileRelativePath}" > /dev/null; then  #// If the file in working does not changed

        echo  "Copy a file from \"${repositoryFolderPath}/${fileRelativePath}\" to \"${PWD}/${fileRelativePath}\""
        cp -ap  "${repositoryFolderPath}/${fileRelativePath}"  "${fileRelativePath}"
        return
    fi

    #// Create ".commit_theirs" folder
    local  destination=".commit_theirs/${fileRelativePath}"
    local  destinationParent="${destination%/*}"
    mkdir -p  "${destinationParent}"
    rm -f  ".commit_theirs/${fileRelativePath}"

    cp  "${repositoryFolderPath}/${fileRelativePath}"  ".commit_theirs/${fileRelativePath}"
    SetReadOnly  ".commit_theirs/${fileRelativePath}"
    echo  "Copied a file in repository folder to \".commit_theirs\" folder"

    #// Create ".commit_ours" folder
    local  destination=".commit_ours/${fileRelativePath}"
    local  destinationParent="${destination%/*}"
    mkdir -p  "${destinationParent}"
    rm -f  ".commit_ours/${fileRelativePath}"

    cp  "${fileRelativePath}"  ".commit_ours/${fileRelativePath}"
    SetReadOnly  ".commit_ours/${fileRelativePath}"
    echo  "Copied a file in current folder to \".commit_ours\" folder"

    #// Merge
    #// source: ".commit_theirs" folder
    #// destination: current folder
    DeleteFolder    ".commit_merging"
    mkdir -p  ".commit_merging"
    local  mergingFolderPath="$( readlink -f ".commit_merging" )"
    local  rsyncUsed="${False}"
    if IsWindowsFolder  "${mergingFolderPath}"; then
        if [ "${LOCOMMIT_TMP}" != "" ]; then
            echo  "Using LOCOMMIT_TMP (${LOCOMMIT_TMP}) because \"${mergingFolderPath}\" is Windows shared folder."
            RsyncToTemporary  "${mergingFolderPath}"  "${LOCOMMIT_TMP}"
            mergingFolderPath="${LOCOMMIT_TMP}${mergingFolderPath}"
            local  rsyncUsed="${True}"
        else
            echo  "LOCOMMIT_TMP environment variable is not set though \"${mergingFolderPath}\" is Windows shared folder."
        fi
    fi
    local  currentFolder="${PWD}"
    pushd  "${mergingFolderPath}" > /dev/null  ||  Error

        #// Make common commit
        cp  "${currentFolder}/.commit/${fileRelativePath}"  "."
        SetNotReadOnly  "${fileName}"
        GitInit
        git add  "." > /dev/null
        git commit  -m "locommit pull) Created a common commit." > /dev/null  #// Ignore this command errors
        local  currentBranch=$( git rev-parse --abbrev-ref HEAD  || echo "(ERROR)" )
        ErrorIfLastIs  "${currentBranch}"  "(ERROR)"

        #// Make commit_theirs
        cp  "${currentFolder}/.commit_theirs/${fileRelativePath}"  "."
        SetNotReadOnly  "${fileName}"
        git checkout -b "__locommit_commit_theirs" > /dev/null 2>&1  ||  Error
        git add "." > /dev/null
        git commit  -m "locommit pull) commit_theirs" > /dev/null  #// Ignore this command errors

        #// Make commit_ours
        git checkout "${currentBranch}" > /dev/null 2>&1  ||  Error
        cp  "${currentFolder}/.commit_ours/${fileRelativePath}"  "."
        SetNotReadOnly  "${fileName}"
        git checkout -b "__locommit_commit_ours" > /dev/null 2>&1  ||  Error
        git add "." > /dev/null
        git commit  -m "locommit pull) commit_ours" > /dev/null  #// Ignore this command errors

        #// Merge
        local  mergeLog="$( git merge  "__locommit_commit_theirs" --no-edit  2>&1  ||  echo "(ERROR)" )"
        if echo "${mergeLog}" | grep "Abort."; then
            echo "${mergeLog}"
            Error  "failed: git merge .commit_theirs"
        fi
    popd > /dev/null
    if [ "${rsyncUsed}" == "${True}" ]; then
        RsyncFromTemporary  "${mergingFolderPath}"  "${LOCOMMIT_TMP}"
    fi

    cp -ap  ".commit_merging/${fileName}"  "."
    DeleteFolder  ".commit_merging"
}

function  InitBarePush() {
    local  newRepositoryFolderPath="$1"
    newRepositoryFolderPath=$( ResolvePath "${newRepositoryFolderPath}"  || echo "(ERROR)" )
    ErrorIfLastIs  "${newRepositoryFolderPath}"  "(ERROR)"
    if [ "${Options_Branch}" == "" ]; then
        local  branch="$( GetCurrentGitBranch )"
        if [ "${branch}" == "" ]; then
            branch="main"
        fi
    else
        local  branch="${Options_Branch}"
    fi
    if [ "${newRepositoryFolderPath}" == "" ]; then
        Error  "Not specified new repository folder.  Expected command: locommit init-bare-push __NewRepositoryFolderPath__"
    fi
    if [ -e ".git" ]; then
        local  dotGitExistsInCurrentFolder="${True}"
    else
        local  dotGitExistsInCurrentFolder="${False}"
    fi
    AssertNotExist  "${newRepositoryFolderPath}"
    StartInTemporary  "LOCOMMIT_TMP"  "${LOCOMMIT_TMP}"
    local  currentFolder="${PWD}"
    if [ "${dotGitExistsInCurrentFolder}" == "${False}" ]; then
        GitInit
        git add "."  > /dev/null  2>&1
        git commit  -m "locommit) Created by InitBarePush"  > /dev/null  2>&1
        local  allFilesAreGitAdd="${True}"
    else
        CheckIfGitResetState
        if AllFilesAreGitAdd; then
            local  allFilesAreGitAdd="${True}"
        else
            local  allFilesAreGitAdd="${False}"
        fi
        git add "."  > /dev/null  2>&1
    fi

    #// Copy files
    mkdir -p ".commit_init-bare-push"

    git checkout-index -fau --prefix=".commit_init-bare-push/"
    EndInTemporary  "LOCOMMIT_TMP"  "${LOCOMMIT_TMP}"

    #// Create new repository
    mkdir -p "${newRepositoryFolderPath}"
    pushd  "${newRepositoryFolderPath}"  >  /dev/null
    local  newRepositoryFullPath="${PWD}"
    StartInTemporary  "LOCOMMIT_TMP"  "${LOCOMMIT_TMP}"

    git init --bare --shared=true
    git symbolic-ref HEAD refs/heads/${branch}
    EndInTemporary  "LOCOMMIT_TMP"  "${LOCOMMIT_TMP}"
    popd  >  /dev/null

    #// Make a commit
    pushd  ".commit_init-bare-push"  >  /dev/null
    StartInTemporary  "LOCOMMIT_TMP"  "${LOCOMMIT_TMP}"

    GitInit
    git remote add origin "file://${newRepositoryFullPath}"
    git checkout -b "${branch}"
    git add "."  > /dev/null  2>&1

    git commit  -m "locommit) Created a local repository"  > /dev/null  2>&1
    git symbolic-ref HEAD refs/heads/${branch}
    git push --set-upstream origin ${branch}
    EndInTemporary  "LOCOMMIT_TMP"  "${LOCOMMIT_TMP}"
    popd  >  /dev/null

    #// Clean
    git status  > /dev/null  #// Change directory in git process(?) for deleting Windows folder
    if [ "${dotGitExistsInCurrentFolder}" == "${False}" ]; then
        DeleteFolder  "${currentFolder}/.git"
    fi
    DeleteFolder  ".commit_init-bare-push"
    AssertNotExist  ".commit_init-bare-push"
    echo  "Removed \".commit_init-bare-push\" temporary folder."
    if [ "${allFilesAreGitAdd}" == "${False}" ]; then
        StartInTemporary  "LOCOMMIT_TMP"  "${LOCOMMIT_TMP}"
        git reset  > /dev/null  2>&1
        EndInTemporary  "LOCOMMIT_TMP"  "${LOCOMMIT_TMP}"
    fi
}

function  AllFilesAreGitAdd() {
    local  status="$( git status --short )"

    if [ "${status}" == "" ]; then
        return  "${False}"
    else
        echo  "${status}" | grep -E '^ [^ ]' > /dev/null;
        test "$?" != 0
        return  $?
    fi
}

function  GitInit() {
    git init ${GitInitOption}  > /dev/null  2>&1  ||  Error
    git config --local user.email "${LocommitEMail}"
    git config --local user.name  "${LocommitUser}"
    git config --local core.fileMode  false
}

function  CheckIfGitResetState() {  #// All files are git added or not git added
    local  status="$( git status --short )"

    #// Error, if one or more files are git added
    # M  edit.txt    ... after git add ... Error
    #  M edit.txt    ... before git add ... OK
    # M  ../edit.txt ... after git add but out of folder ... OK
    # M  .hidden.txt ... not out of folder ... Error
    # ?? new.txt     ... untracked ... OK
    if echo  "${status}"  |  grep -E '^[^ ?]. .[^.]' > /dev/null; then

        #// Error, if one or more files are not git added
        # M  edit.txt    ... after git add ... OK
        #  M edit.txt    ... before git add ... Error
        #  M ../edit.txt ... after git add but out of folder ... OK
        #  M .hidden.txt ... not out of folder ... Error
        # ?? new.txt     ... untracked ... Error
        if echo  "${status}"  |  grep -E '^.[^ ] .[^.]' > /dev/null; then
            echo  '$ git status --short'
            echo  "${status}"
            Error  'ERROR: this command does not supported, when files were git added. You can clone, if you run git reset ".".'
        fi
    fi
}

function  Test_CheckIfGitResetState() {

    #// Error, if one or more files are git added
    echo 'M  edit.txt'    | grep -E '^[^ ?]. .[^.]'  ||  Error
    echo ' M edit.txt'    | grep -E '^[^ ?]. .[^.]'  &&  Error
    echo 'M  ../edit.txt' | grep -E '^[^ ?]. .[^.]'  &&  Error
    echo 'M  .hidden.txt' | grep -E '^[^ ?]. .[^.]'  ||  Error
    echo '?? new.txt'     | grep -E '^[^ ?]. .[^.]'  &&  Error
        # &&: Error if match ... CheckIfGitResetState is successed.
        # ||: Error if not match ... CheckIfGitResetState raises an error.

    #// Error, if one or more files are not git added
    echo 'M  edit.txt'    | grep -E '^.[^ ] .[^.]'  &&  Error
    echo ' M edit.txt'    | grep -E '^.[^ ] .[^.]'  ||  Error
    echo ' M ../edit.txt' | grep -E '^.[^ ] .[^.]'  &&  Error
    echo ' M .hidden.txt' | grep -E '^.[^ ] .[^.]'  ||  Error
    echo '?? new.txt'     | grep -E '^.[^ ] .[^.]'  ||  Error
        # &&: Error if match ... CheckIfGitResetState is successed.
        # ||: Error if not match ... CheckIfGitResetState raises an error.
}

function  EchoWithIndent() {
    local  message="$1"
    local  indent="$2"
    local  oldIFS="$IFS"

    IFS=$'\n'
    for  line  in ${message}; do
        echo "${indent}${line}"
    done
    IFS="$oldIFS"
}

function  ResolvePath() {
    local  path_="$1"

    path_="$( echo "${path_}" | sed -e 's/\\/\//g' | sed -e 's/^C:/c:/'  || echo "(ERROR)" )"  #// replace to / and c:
    ErrorIfLastIs  "${path_}"  "(ERROR)"

    if [ "${mnt_c}" == "" ]; then
        export  mnt_c="/mnt/c";  if [ ! -e "/mnt/c" ]; then  export  mnt_c="c:"  ;fi
    fi
    if [ "${path_:0:3}" == "c:/"  -o  "${path_:0:3}" == "/c/" ]; then
        path_="${mnt_c}/${path_:3}"
    elif [ "${path_:0:7}" == "/mnt/c/" ]; then
        path_="${mnt_c}/${path_:7}"
    fi

    echo  "${path_}"
}

function  GetGitWorkingRootPath() {
    local  path="${PWD}"
    while [ "${path}" != "" ]; do

        if [ -e "${path}/.git" ]; then
            echo  "${path}"
            return
        fi
        path="${path%/*}"
    done

    echo  ""
}

function  GetCurrentGitBranch() {
    git rev-parse --abbrev-ref HEAD
}

function  GetRelativePath() {
    local  fullPath="$1"
    local  basePath="$2"

    local  relativePath=$( echo "$fullPath" | sed -e "s%^${basePath}/%%"  || echo "(ERROR)" )
    ErrorIfLastIs  "${relativePath}"  "(ERROR)"
    echo  "${relativePath}"
}

function  CopyFolder() {
    local  source="$1"
    local  destination="$2"
    local  ignoreDotGit="$3"  #// ${True}, ${False}(default)
    local  excludeOption="--exclude=./.git"
    source="$( CutLastOf  "${source}"  "/"  || echo "(ERROR)" )"
    destination="$( CutLastOf  "${destination}"  "/"  || echo "(ERROR)" )"
    ErrorIfLastIs  "${source}"  "(ERROR)"
    ErrorIfLastIs  "${destination}"  "(ERROR)"
    if [ "${ignoreDotGit}" != ""  -a  "${ignoreDotGit}" != "${excludeOption}" ]; then
        Error  "Bad option: ${ignoreDotGit}"
        return  "${False}"
    fi

    mkdir -p  "${destination}/"
    if [ "${ignoreDotGit}" == "${excludeOption}" ]; then
        ls -a "${source}" | grep -v  -e "^\.git$"  -e "^\.$"  -e "^\.\.$" | xargs  -I {} \
            cp -Rap  "${source}/{}"  "${destination}/"
    else
        ls -a "${source}" | grep -v  -e "^\.$"  -e "^\.\.$" | xargs  -I {} \
            cp -Rap  "${source}/{}"  "${destination}/"
    fi
}

function  DeleteFolder() {
    local  folderPath="$1"
    local  retryCount=5
    if [ ! -e "${folderPath}" ]; then
        return
    fi

    SetNotReadOnly "${folderPath}"  #// For CentOS7 Vagrant shared folder
    while true; do

        rm -rf  "${folderPath}"
        if [ "$?" == 0 ]; then
            return
        fi

        retryCount="$(( ${retryCount} - 1 ))"
        if [ "${retryCount}" == "0" ]; then
            Error  "Cannot delete a folder \"${folderPath}\""
        fi
        sleep 2s
    done
}

function  StartInTemporary() {
    local  temporaryPathVariableName="$1"
    local  temporaryPathValue="$2"
    local  currentFolder="${PWD}"

    if IsWindowsFolder  "${currentFolder}"; then
        if [ "${temporaryPathValue}" != "" ]; then
            echo  "Using ${temporaryPathVariableName} (${temporaryPathValue}) because \"${currentFolder}\" is Windows shared folder."

            RsyncToTemporary  "${currentFolder}"  "${temporaryPathValue}"

            pushd  "${temporaryPathValue}${currentFolder}" > /dev/null  ||  Error
        else
            echo  "${temporaryPathVariableName} environment variable is not set though \"${currentFolder}\" is Windows shared folder."
        fi
    fi
}

function  EndInTemporary() {
    local  temporaryPathVariableName="$1"
    local  temporaryPathValue="$2"
    local  currentFolder="${PWD}"
    if [ "${temporaryPathValue}" == "" ]; then
        return
    fi

    if StartsWith  "${currentFolder}/"  "${temporaryPathValue}/"; then

        RsyncFromTemporary  "${currentFolder}"  "${temporaryPathValue}"

        popd  > /dev/null
    fi
}

function  RsyncToTemporary() {
    local  folderPath="$1"
    local  temporaryPath="$2"
    local  waitTime="$3"  #// "", 0 or 1s.  ""=1s
    if [ "${waitTime}" == "" ]; then
        waitTime="1s"
    fi
    test  "${folderPath:0:1}" == "/"  ||  Error  "ERROR: RsyncToTemporary requests full path. folderPath: \"${folderPath}\""
    test  "${temporaryPath:0:1}" == "/"  ||  Error  "ERROR: RsyncToTemporary requests full path. temporaryPath: \"${temporaryPath}\""
    mkdir -p  "${temporaryPath}${folderPath}"

    rsync --recursive --delete --times  "${folderPath}/"  "${temporaryPath}${folderPath}/"  ||  Error
        #// It is necessary to set "--times" for Windows share folder
    sleep  "${waitTime}"
    return 0
}

function  RsyncFromTemporary() {
    #// Command "RsyncFromTemporary /tmp/folder/to /tmp" copies to /folder/to
    local  folderPathInTemporary="$1"
    local  temporaryPath="$2"
    local  waitTime="$3"  #// "", 0 or 1s.  ""=1s
    if [ "${waitTime}" == "" ]; then
        waitTime="1s"
    fi
    test  "${folderPathInTemporary:0:1}" == "/"  ||  Error  "ERROR: RsyncFromTemporary requests full path. folderPathInTemporary: \"${folderPathInTemporary}\""
    test  "${temporaryPath:0:1}" == "/"  ||  Error  "ERROR: RsyncFromTemporary requests full path. temporaryPath: \"${temporaryPath}\""
    StartsWith  "${folderPathInTemporary}/"  "${temporaryPath}/"  ||  Error

    local  destinationFolderPath="${folderPathInTemporary:${#temporaryPath}}"
    mkdir -p  "${destinationFolderPath}"
    local  readOnlyFiles="$( find "${destinationFolderPath}" -type f ! -perm -u=w )"
    echo  "${readOnlyFiles}"  |  xargs -I{} chmod 777 "{}"  #// For rsync can overwrite files in Windows share folder

    rsync --recursive --delete --times --inplace  "${folderPathInTemporary}/"  "${destinationFolderPath}/"  ||  Error
        #// It is necessary to set "--inplace" for Windows share folder. "--inplace" does not rename in rsync.
    echo  "${readOnlyFiles}"  |  xargs -I{}  sh -c 'test -e "{}"  &&  chmod 444 "{}"'
        #// For not changed read only files in Windows share folder
    sleep  "${waitTime}"
    return 0
}

function  IsWindowsFile() {  #// Shared file with Windows in Linux process
    local  filePath="$1"
    if [ -d "${filePath}" ]; then Error ;fi

    if df -h "${filePath}"  |  grep -E '/dev/' > /dev/null; then  #// Linux file system
        return "${False}"  #// Linux file
    else
        return "${True}"  #// Windows file
    fi
}

function  IsWindowsFolder() {
    local  folderPath="$1"
    echo  "x"  >  "${folderPath}/.commit_tmp"

    IsWindowsFile  "${folderPath}/.commit_tmp"
    local  returnValue=$?
    rm  "${folderPath}/.commit_tmp"
    return  "${returnValue}"
}

function  SetReadOnly() {
    SetReadOnlyOrNot --set-read-only  "$@"
}

function  SetNotReadOnly() {
    SetReadOnlyOrNot --set-not-read-only  "$@"
}

if [ "${READ_ONLY_CHMOD}" == "" ]; then
    READ_ONLY_CHMOD="a-w"   #// For Linux only
fi
if [ "${NOT_READ_ONLY_CHMOD}" == "" ]; then
    NOT_READ_ONLY_CHMOD="u+w"   #// For Linux only
fi

function  SetReadOnlyOrNot() {
    local  operation="$1"
    local  fileOrFolderPath="$2"

    if [ -f "${fileOrFolderPath}" ]; then
        local  filePath="${fileOrFolderPath}"
        if [ "${operation}" == "--set-read-only" ]; then
            if IsWindowsFile "${filePath}"; then

                chmod 444  "${filePath}"
            else
                chmod ${READ_ONLY_CHMOD}  "${filePath}"
            fi
        elif [ "${operation}" == "--set-not-read-only" ]; then
            if IsWindowsFile "${filePath}"; then

                chmod 777  "${filePath}"
            else
                chmod ${NOT_READ_ONLY_CHMOD}  "${filePath}"
            fi
        fi

    elif [ -d "${fileOrFolderPath}" ]; then
        local  folderPath="${fileOrFolderPath}"
        local  filePaths="$( find "${folderPath}"  -type f )"
        local  firstFilePath="$( echo  "${filePaths}"  |  head -1 )"
        if [ "${firstFilePath}" != "" ]; then
            if [ "${operation}" == "--set-read-only" ]; then
                if IsWindowsFile "${firstFilePath}"; then
                    echo  "${filePaths}"  |  xargs -I{} chmod 444 "{}"
                else
                    echo  "${filePaths}"  |  xargs -I{} chmod ${READ_ONLY_CHMOD} "{}"
                fi
            elif [ "${operation}" == "--set-not-read-only" ]; then
                if IsWindowsFile "${firstFilePath}"; then

                    echo  "${filePaths}"  |  xargs -I{} chmod 777 "{}"
                else
                    echo  "${filePaths}"  |  xargs -I{} chmod ${NOT_READ_ONLY_CHMOD} "{}"
                fi
            fi
        fi
    fi
}

function  CutCommonPartLines() {
    local  targetLines="$1"
    local  cuttingPartLines="$2"

    #// targetLines - cuttingPartLines
    if [ "${cuttingPartLines}" == "" ]; then
        echo  "${targetLines}"  #// Because "grep -vFf /dev/null" returns empty
    else
        echo  "${targetLines}"  |  grep -vFf <( echo "${cuttingPartLines}" )
    fi

    #// If a cutting line contains in a part of target line, cut the target line.
    #// Example:
    #//     targetLines:
    #//         ab
    #//         cd
    #//         ef
    #//     cuttingPartLines:
    #//         c
    #//     return:
    #//         ab
    #//         ef
}

#// StartsWith
#//     e.g.) if StartsWith  ${wholeString} ${partString}; then
function  StartsWith() {
    local  wholeString="$1"
    local  partString="$2"
    local  partLength=${#partString}

    #// Set exit code
    [ "${wholeString:0:${partLength}}" == "${partString}" ]
}

function  CutLastOf() {
    local  wholeString="$1"
    local  lastExpected="$2"

    if [ "${wholeString:${#wholeString}-${#lastExpected}:${#lastExpected}}" == "${lastExpected}" ]; then
        echo  "${wholeString:0:${#wholeString}-${#lastExpected}}"
    else
        echo  "${wholeString}"
    fi
}

function  gitInitOption() {
    if [ "$( LessThanVersion "$(git --version)" "2.31.1")" == "${True}" ]; then
        echo  ""
    else
        echo  "-bmain"  #// "-b main" occurs an error in bash debug
    fi
}

# LessThanVersion
#     if [ "$( LessThanVersion "$(git --version)" "2.31.1")" == "${True}" ]; then
function  LessThanVersion() {
    local  textContainsVersionA="$1"
    local  textContainsVersionB="$2"
    local  isGoodFormat="${True}"
    echo "${textContainsVersionA}" | grep -e "[0-9]\+\.[0-9]\+\.[0-9]\+" > /dev/null  ||  isGoodFormat="${False}"
    echo "${textContainsVersionB}" | grep -e "[0-9]\+\.[0-9]\+\.[0-9]\+" > /dev/null  ||  isGoodFormat="${False}"
    if [ "${isGoodFormat}" == "${False}" ]; then
        Error  "\"${textContainsVersionA}\" or \"${textContainsVersionB}\" is not semantic version."
    fi

    local  numbersA=( $( echo "${textContainsVersionA}" | grep -o -e "[0-9]\+" ) )
    local  numbersB=( $( echo "${textContainsVersionB}" | grep -o -e "[0-9]\+" ) )
    if [ "${numbersA[0]}" -lt "${numbersB[0]}" ]; then
        echo "${True}"
        return
    elif [ "${numbersA[0]}" == "${numbersB[0]}" ]; then
        if [ "${numbersA[1]}" -lt "${numbersB[1]}" ]; then
            echo "${True}"
            return
        elif [ "${numbersA[1]}" == "${numbersB[1]}" ]; then
            if [ "${numbersA[2]}" -lt "${numbersB[2]}" ]; then
                echo "${True}"
                return
            fi
        fi
    fi
    echo "${False}"
}

function  AssertExist() {
    local  path="$1"

    if [ ! -e "${path}" ]; then
        Error  "Not found \"${path}\""
    fi
}

function  AssertNotExist() {
    local  path="$1"

    if [ -e "${path}" ]; then
        Error  "Found \"${path}\""
    fi
}

function  AssertInstalled() {
    local  checkingCommand="$1"
    local  exists=${False}
    which "${checkingCommand}" > /dev/null  &&  exists=${True}

    if [ "${exists}" == ${False} ]; then
        Error  "Not installed \"${checkingCommand}\" command"
    fi
}

# pp
#     Debug print
# Example:
#     pp "$config"
#     pp "$config" config
#     pp "$array" array  ${#array[@]}  "${array[@]}"
#     pp "123"
#     $( pp "$config" >&2 )
function  pp() {
    local  value="$1"
    local  variableName="$2"
    if [ "${variableName}" != "" ]; then  variableName=" ${variableName} "  ;fi  #// Add spaces
    local  oldIFS="$IFS"
    IFS=$'\n'
    local  valueLines=( ${value} )
    IFS="$oldIFS"

    local  type=""
    if [ "${variableName}" != "" ]; then
        if [[ "$(declare -p ${variableName} 2>&1 )" =~ "declare -a" ]]; then
            local  type="array"
        fi
    fi
    if [ "${type}" == "" ]; then
        if [ "${#valueLines[@]}" == 1  -o  "${#valueLines[@]}" == 0 ]; then
            local  type="oneLine"
        else
            local  type="multiLine"
        fi
    fi

    if [[ "${type}" == "oneLine" ]]; then
        echo  "@@@${variableName}= \"${value}\" ---------------------------"  >&2
    elif [[ "${type}" == "multiLine" ]]; then
        echo  "@@@${variableName}---------------------------"  >&2
        echo  "\"${value}\"" >&2
    elif [[ "${type}" == "array" ]]; then
        echo  "@@@${variableName}---------------------------"  >&2
        local  count="$3"
        if [ "${count}" == "" ]; then
            echo  "[0]: \"$4\""  >&2
            echo  "[1]: ERROR: pp parameter is too few"  >&2
        else
            local  i=""
            for (( i = 0; i < ${count}; i += 1 ));do
                echo  "[$i]: \"$4\""  >&2
                shift
            done
        fi
    else
        echo  "@@@${variableName}? ---------------------------"  >&2
    fi
}

# EndsWith
#    if EndsWith "abc" "bc"; then
function  EndsWith() {
    local  output="$1"
    local  tag="$2"

    local  last="${output:${#output}-${#tag}:${#tag}}"

    if [ "${last}" == "${tag}" ]; then
        return  "${True}"
    else
        return  "${False}"
    fi
}

# ErrorIfLastIs
#     Error check in $( )
#     variable="$( command  || echo "(ERROR)" )"
#     ErrorIfLastIs  "${output}"  "(ERROR)"
function  ErrorIfLastIs() {
    local  output="$1"
    local  tag="$2"

    local  last="${output:${#output}-${#tag}:${#tag}}"

    if [ "${last}" == "${tag}" ]; then
        exit  2
    fi
}

function  Error() {
    local  errorMessage="$1"
    local  exitCode="$2"
    if [ "${errorMessage}" == "" ]; then
        errorMessage="ERROR"
    fi
    if [ "${exitCode}" == "" ]; then  exitCode=2  ;fi

    echo  "${errorMessage}" >&2
    exit  "${exitCode}"
}

True=0
False=1
GitInitOption=$(gitInitOption)
LocommitEMail="locommit@example.com"
LocommitUser="locommit"

Main  "$@"
