#!/bin/bash

PositionalArgs=()
while [[ $# -gt 0 ]]; do
    case $1 in
        --no-git)     Options_NoGit="yes"; shift;;
        -b|--branch)  Options_Branch="$2"; shift; shift;;
        --file)       Options_File="$2"; shift; shift;;
        -*) echo "Unknown option $1"; exit 1;;
        *) PositionalArgs+=("$1"); shift;;
    esac
done
set -- "${PositionalArgs[@]}"  #// set $1, $2, ...
unset PositionalArgs

function  Main() {
    local  subCommand="$1"
    AssertInstalled  "git"
    if [ "${subCommand}" == "" ]; then
        LocalCommit
    elif [ "${subCommand:0:1}" == "-" ]; then
        LocalCommit  "$@"
    elif [ "${subCommand}" == "clone" ]; then
        shift
        Clone  "$@"
    elif [ "${subCommand}" == "status" ]; then
        shift
        LocalCommit  "$@"
    elif [ "${subCommand}" == "push" ]; then
        shift
        Push  "$@"
    elif [ "${subCommand}" == "pull" ]; then
        shift
        Pull  "$@"
    elif [ "${subCommand}" == "pull-base" ]; then
        shift
        PullBase  "$@"
    elif [ "${subCommand}" == "init-bare-push" ]; then
        shift
        InitBarePush  "$@"
    else
        Error  "ERROR: Unknown sub command \"${subCommand}\""
    fi
}

function  LocalCommit() {
    local  option="$1"
    local  noGitOption="${False}"
    if [ "${option}" == "--no-git"  -o  "${Options_NoGit}" != "" ]; then
        noGitOption="${True}"
    elif [ "${option}" != "" ]; then
        Error  "Unknown option \"${option}\""
    fi
    local  currentFolder="${PWD}"
    local  gitWorkingRootPath="$( GetGitWorkingRootPath  || echo "(ERROR)" )"
    local  outputFolderName=""
    ErrorIfLastIs  "${gitWorkingRootPath}"  "(ERROR)"
    if [ ! -e ".commit" ]; then
        outputFolderName=".commit"
        if [ "${currentFolder}" == "${gitWorkingRootPath}"  -a  "${noGitOption}" == "${False}" ]; then
            Error  "locommit command cannot create new \".commit\" folder where \".git\" folder exists. You can specify --no-git option."
        fi
    else
        outputFolderName=".commit_new"
    fi

    #// Copy files by "git checkout-index"
    if [ "${gitWorkingRootPath}" == "" ]; then
        rm -rf  "${outputFolderName}"
        if [ "${noGitOption}" == "${False}" ]; then
            echo  "Added .git folder and first commit."
            git init ${GitInitOption}  > /dev/null  2>&1
            git config --local user.email "${LocommitEMail}"
            git config --local user.name  "${LocommitUser}"
            git add "."  > /dev/null  2>&1
            git commit  -m "locommit) Created local working directory"  > /dev/null  2>&1
        else
            git init ${GitInitOption}  > /dev/null  2>&1
            git config --local user.email "${LocommitEMail}"
            git config --local user.name  "${LocommitUser}"
            git add "."  > /dev/null  2>&1
        fi
        mkdir  "${outputFolderName}"

        git checkout-index -fau --prefix="${outputFolderName}/"
        if [ "${noGitOption}" == "${True}" ]; then
            rm -rf  ".git"  #// Temporary .git
            if [ "${gitIgnoreExists}" == "${False}" ]; then
                rm  ".gitignore"
                rm  "${outputFolderName}/.gitignore"
            fi
        fi
    else
        rm -rf  "${outputFolderName}"
        if [ "${currentFolder}" == "${gitWorkingRootPath}" ]; then
            mkdir -p  "${outputFolderName}"
            mv  ".git"  "${outputFolderName}/.commit_.git"
            git init ${GitInitOption}  > /dev/null  #// Temporary .git
            git config --local user.email "${LocommitEMail}"
            git config --local user.name  "${LocommitUser}"
            git add  "."  #// checkout new contents

            git checkout-index -fau --prefix="${outputFolderName}/"
            rm -rf  ".git"  #// Temporary .git
            mv  "${outputFolderName}/.commit_.git"  ".git"
        else  #// There is ".git" folder in parent folder.
            local  gitIgnoreExists="${True}"
            if [ ! -e ".gitignore" ]; then
                gitIgnoreExists="${False}"
                cat  "${gitWorkingRootPath}/.gitignore"  |  grep -v  "^/"  >  ".gitignore"
            fi
            if [ "${noGitOption}" == "${False}" ]; then
                echo  "Added .git folder and first commit."
            fi
            git init ${GitInitOption}  > /dev/null
            git config --local user.email "${LocommitEMail}"
            git config --local user.name  "${LocommitUser}"
            git add  "."
            git commit -m  "locommit) First commit"

            git checkout-index -fau --prefix="${outputFolderName}/"
            if [ "${noGitOption}" == "${True}" ]; then
                rm -rf  ".git"  #// Temporary .git
                if [ "${gitIgnoreExists}" == "${False}" ]; then
                    rm  ".gitignore"
                    rm  "${outputFolderName}/.gitignore"
                fi
            fi
        fi
    fi

    #// Set read only
    if [ "${noGitOption}" == "${False}" ]; then
        find "${outputFolderName}" -type f  |  xargs  -I {} \
            chmod 444 "{}"
    fi

    #// Show conflict file names
    pushd  "${outputFolderName}" > /dev/null

    local  conflictOutput=$( grep -rn  "^<<<<<<<"  "."  |  sed  "s/\\(:[0-9][0-9]*:\\)\\([^ ]\\)/\\1 \\2/"  || echo "(ERROR)" )
    popd > /dev/null
    ErrorIfLastIs  "${conflictOutput}"  "(ERROR)"
    if [ "${conflictOutput}" != "" ]; then
        echo  "CONFLICT:"
        EchoWithIndent  "${conflictOutput}"  "    "
    fi

    #// Show different file names
    if [ "${outputFolderName}" == ".commit" ]; then
        echo  'Created new ".commit" folder.'
        if [ "${noGitOption}" == "${False}" ]; then
            echo  'This will be treated as base commit.'
        fi
    fi

    if [ "${outputFolderName}" == ".commit_new" ]; then
        local  diff_output="$( diff -qr  ".commit"  ".commit_new" )"

        if [ "${diff_output}" == "" ]; then
            rm -rf  ".commit_new"
            echo  'Deleted ".commit_new" folder.'
            echo  'SAME as ".commit" folder.'
        else
            echo  'Created new ".commit_new" folder.'
            echo  'Changes for .commit:'
            EchoWithIndent  "${diff_output}"  "    "
        fi
    fi

    if [ "${gitWorkingRootPath}" == ""  -a  "${noGitOption}" == "${True}" ]; then
        rm -rf  ".git"
    fi
}

function  Clone() {
    local  repositoryFolderPath="$1"
    local  destinationFolderPath="$2"
    if [ "$1" == ""  -o  "$2" == "" ]; then
        Error  "ERROR: locommit clone __RepositoryFolderPath__ __DestinationFolderPath__"
    fi
    if [ "${Options_File}" != "" ]; then
        CloneFile  "$@"
        return $?
    fi
    pushd  "${repositoryFolderPath}"  > /dev/null
    CheckIfGitResetState
    popd  > /dev/null
    repositoryFolderPath=$( ResolvePath "${repositoryFolderPath}" )
    repositoryFolderPath="$( CutLastOf "${repositoryFolderPath}" "/"  || echo "(ERROR)" )"
    AssertExist  "${repositoryFolderPath}"
    if [ -e "${destinationFolderPath}" ]; then
        Error  "fatal: destination path '${destinationFolderPath}' already exists."  128
    fi

    mkdir -p  "${destinationFolderPath}"
    destinationFolderPath="$( readlink -f "${destinationFolderPath}" )"

    pushd  "${repositoryFolderPath}"  > /dev/null
    if [ -e ".git" ]; then
        local  hasDotGit="${True}"
    else
        local  hasDotGit="${False}"
        git init ${GitInitOption}  > /dev/null  2>&1
        git config --local user.email "${LocommitEMail}"
        git config --local user.name  "${LocommitUser}"
    fi
    git reset "."  > /dev/null
    git rm -r --cached  "."  > /dev/null  2>&1
    git add "."  > /dev/null  2>&1
    mkdir -p  "${destinationFolderPath}"

    git checkout-index -fau --prefix="${destinationFolderPath}/.commit/"
    git reset "."  > /dev/null
    echo  'Created new ".commit" folder.'
    CopyFolder  "${destinationFolderPath}/.commit"  "${destinationFolderPath}"
    find  "${destinationFolderPath}/.commit" -type f  |  xargs  -I {} \
        chmod 444 "{}"
    if [ "${hasDotGit}" == "${False}" ]; then
        rm -rf  "${repositoryFolderPath}/.git"
    fi

    cd  "${destinationFolderPath}"
    git init ${GitInitOption}  > /dev/null  2>&1
    git config --local user.email "${LocommitEMail}"
    git config --local user.name  "${LocommitUser}"
    git add "."  > /dev/null  2>&1
    git commit -m  "locommit) First commit"  > /dev/null
    popd  > /dev/null
}

function  CloneFile() {
    local  repositoryFolderPath="$1"
    local  destinationFolderPath="$2"
    local  fileRelativePath="${Options_File}"
    local  fileName="${fileRelativePath##*/}"
    if [ "$1" == ""  -o  "$2" == "" ]; then
        Error  "ERROR: locommit clone __RepositoryFolderPath__ __DestinationFolderPath__"
    fi
    repositoryFolderPath="$( CutLastOf "${repositoryFolderPath}" "/"  || echo "(ERROR)" )"
    destinationFolderPath="$( CutLastOf "${destinationFolderPath}" "/"  || echo "(ERROR)" )"
    AssertExist  "${repositoryFolderPath}"
    if [ -e "${destinationFolderPath}" ]; then
        Error  "fatal: destination path '${destinationFolderPath}' already exists."  128
    fi
    local  destinationFilePath="${destinationFolderPath}/${fileRelativePath}"
    local  destinationFileParent="${destinationFilePath%/*}"
    mkdir -p  "${destinationFileParent}/.commit"

    cp -ap  "${repositoryFolderPath}/${fileRelativePath}"  "${destinationFilePath}"
    cp -ap  "${repositoryFolderPath}/${fileRelativePath}"  "${destinationFileParent}/.commit"
    chmod 444  "${destinationFileParent}/.commit/${fileName}"
}

function  Push() {
    local  repositoryFolderPath="$1"
    local  repositoryFolderPath=$( ResolvePath "${repositoryFolderPath}" )
    repositoryFolderPath="$( CutLastOf "${repositoryFolderPath}" "/"  || echo "(ERROR)" )"
    ErrorIfLastIs  "${repositoryFolderPath}"  "(ERROR)"
    if [ "${repositoryFolderPath}" == "" ]; then
        Error  "Not specified destination repository folder. Run the command: locommit push __RepositoryFolderPath__"
    fi
    if [ ! -e ".commit" ]; then
        PushWithoutLocalCommit  "$@"
        return
    fi
    AssertExist  "${repositoryFolderPath}"
    AssertExist  ".commit"
    local  source=".commit_new"
    if [ ! -e ".commit_new" ]; then
        source=".commit"
    fi

    #// (.commit case) Check no update
    if [ "${source}" == ".commit" ]; then
        LocalCommit > /dev/null
        if [ -e ".commit_new" ]; then
            rm -rf  ".commit_new"
            Error  "push command requires .commit_new folder, if update file exists. Run locommit command."
        fi
    fi

    #// Copy files and disable read only
    if [ "${repositoryFolderPath}" != "/dev/null" ]; then

        #// Check "repositoryFolderPath". It prevents to delete "source" folder.
        local  sourceFullPath="$( readlink -f "${source}" )/"
        local  repositoryFullPath="$( readlink -f "${repositoryFolderPath}" )/"
        if StartsWith  "${sourceFullPath}"  "${repositoryFullPath}"; then
            Error  "push 先は カレント フォルダー の外に指定する必要があります"  #// "Push target must be out of current folder"
        fi

        #// Copy files and disable read only
        echo  "Copied files and disabled read only to \"${repositoryFolderPath}\" folder"
        CopyFolder  "${source}"  "${repositoryFolderPath}"  "--exclude=./.git"
        find "${repositoryFolderPath}" -type f  |  xargs -I {} \
            chmod +w "{}"

        #// Delete deleted files
        if [ "${source}" == ".commit_new" ]; then
            local  oldFileNames="$( find ".commit"     -type f  |  sed -E 's/$/:/' )"
            local  newFileNames="$( find ".commit_new" -type f  |  sed -E 's/$/:/'  |  sed -E 's/^.commit_new/.commit/' )"
            local  deletingFileNames="$( CutCommonPartLines  "${oldFileNames}"  "${newFileNames}" )"
            deletingFileNames="$( echo "${deletingFileNames}"  |  sed -E 's|^.commit/||'  |  sed -E 's|:$||' )"
            if [ "${deletingFileNames}" != "" ]; then
                echo  "Deleting some files in \"${repositoryFolderPath}\" folder"
                local  oldIFS="$IFS"
                IFS=$'\n'
                for fileName in ${deletingFileNames}; do
                    rm -f  "${repositoryFolderPath}/${fileName}"
                done
                IFS="$oldIFS"
            fi
        fi
    fi

    #// (.commit_new case) Update .commit folder
    if [ "${source}" == ".commit_new" ]; then
        echo  "Moved \".commit_new\" to \".commit\" folder"
        rm -rf  ".commit"
        mv  ".commit_new"  ".commit"
    fi
    rm -rf ".commit_ours"
    rm -rf ".commit_theirs"
    rm -rf ".commit_old_ours"
    rm -rf ".commit_old_base"

    #// git commit
    if [ -e ".git" ]; then
        if [ "$(git status --short)" != "" ]; then
            git add "."
            git commit  -m "locommit push) Updated." > /dev/null
        fi
    fi
}

function  PushWithoutLocalCommit() {
    local  outputFolderPath="$1"
    AssertExist  "${outputFolderPath}"
    AssertNotExist  ".commit"
    if [ ! -e ".git" ]; then
        Error  "locommit push command requires \".commit\" or \".git\" folder."
    fi
    rm -rf  "${outputFolderPath}"
    mkdir  "${outputFolderPath}"

    git checkout-index -fau --prefix="${outputFolderPath}/"
}

function  Pull() {
    #   *   4 (pulled)
    #   |\
    #   | * 3 _repository
    #   * | 2 .commit_new
    #   |/
    #   *   1 .commit
    if [ "${Options_File}" == "" ]; then
        PullSub  "$1"  --pull
    else
        PullFile  "$1"  --pull
    fi
}

function  PullSub() {
    local  repositoryFolderPath_="$1"
    local  option="$2"  #// "--pull" or "--pull-base"
    local  baseFolderRelativePath="$3"  #// This is enabled if option == "--pull-base"
    local  repositoryFolderPath_=$( ResolvePath "${repositoryFolderPath_}"  || echo "(ERROR)" )
    local  repositoryFolderPath="$( CutLastOf "${repositoryFolderPath_}" "/"  || echo "(ERROR)" )"
    ErrorIfLastIs  "${repositoryFolderPath_}"  "(ERROR)"
    ErrorIfLastIs  "${repositoryFolderPath}"  "(ERROR)"
    if [ "${repositoryFolderPath}" == "" ]; then
        Error  "Not specified repository folder.  Expected command: locommit pull __RepositoryFolderPath__"
    fi
    if [ "${baseFolderRelativePath:0:2}" == ".." ]; then  Error;  fi
    if [ "${baseFolderRelativePath:0:1}" == "/" ]; then  Error;  fi
    AssertExist  "${repositoryFolderPath}"
    AssertExist  ".commit"
    local  source=".commit_new"
    if [ ! -e ".commit_new" ]; then
        source=".commit"
    fi

    #// Create ".commit_new" folder
    if [ "${source}" == ".commit" ]; then
        echo  'Created new ".commit_new" folder.'
        LocalCommit > /dev/null
        if [ -e ".commit_new" ]; then
            source=".commit_new"
        fi
    fi
    if [ "${option}" == "--pull-base" ]; then
        rm -rf  "${source}/${baseFolderRelativePath}"
    fi

    #// Create ".commit_theirs" folder
    #// ".commit_theirs" is a copy of a folder in related repository at
    #// "repositoryFolderPath", except for the files covered by ".gitignore".
        AssertNotExist  "${repositoryFolderPath}/.commit_new"
        local  thereIsRepositoryCommit=${False}
        if [ -e "${repositoryFolderPath}/.commit" ]; then
            thereIsRepositoryCommit=${True}
        fi

        #// Create ".commit_theirs" folder
        rm -rf  ".commit_theirs"
        pushd  "${repositoryFolderPath}" > /dev/null

        LocalCommit --no-git > /dev/null
        popd > /dev/null
        if [ -e "${repositoryFolderPath}/.commit_new" ]; then
            mv  "${repositoryFolderPath}/.commit_new"  ".commit_theirs"
        else
            if [ "${thereIsRepositoryCommit}" == "${True}" ]; then
                CopyFolder  "${repositoryFolderPath}/.commit"  ".commit_theirs"
            else
                mv  "${repositoryFolderPath}/.commit"  ".commit_theirs"
            fi
        fi
        echo  "Copied a repository folder to \".commit_theirs\" folder"

    #// Create ".commit_ours" folder
    if [ "${source}" == ".commit_new" ]; then
        rm -rf  ".commit_ours"
        mv  ".commit_new"  ".commit_ours"
        echo  "Renamed \".commit_new\" folder to \".commit_ours\" folder"
    else
        rm -rf    ".commit_ours"
        mkdir -p  ".commit_ours"
        ls -a ".commit" | grep -v  -e "^\.$"  -e "^\.\.$" | xargs  -I {} \
            cp -Rap  ".commit/{}"  ".commit_ours"
        rm -rf  ".commit_ours/.git"
        echo  "Copied \".commit\" folder to \".commit_ours\" folder"
    fi

    #// Add to stage in parent .git, if the parent .git includes current folder.
    local  parentDotGit="${False}"
    if [ ! -e ".git" ]; then
        parentDotGit="${True}"
        git add  "."  > /dev/null
    fi

    #// Make a ".git" folder that has "commit_reposiroty" branch
    echo  "Pull from \".commit_theirs\" folder"
    local  currentBranch=$( git rev-parse --abbrev-ref HEAD  || echo "(ERROR)" )
    ErrorIfLastIs  "${currentBranch}"  "(ERROR)"

    #// Check ".commit" folder
    pushd  ".commit" > /dev/null
        if [ -e "../.git" ]; then
            mv  "../.git"  "."
            local  clean="${False}"
            if [ "$(git status --short)" == "" ]; then
                clean="${True}"
            fi
            if [ "${clean}" == "${False}" ]; then
                git add "."
                git commit -m "Reverted to .commit contents."  > /dev/null
                if [ "${option}" == "--pull" ]; then
                    echo  "Added a commit of \".commit\" contents."
                else
                    echo  "Added a commit of old \"${baseFolderRelativePath}\" contents."
                fi
                if [ "$(git status --short)" != "" ]; then
                    mv  ".git"  ".."
                    popd  > /dev/null
                    Error  ".commit folder is not git clean status"
                fi
            fi

            mkdir -p  "../.commit_theirs/.git"
            ls -a ".git" | grep -v  -e "^\.$"  -e "^\.\.$" | xargs  -I {} \
                cp -Rap  ".git/{}"  "../.commit_theirs/.git"
            mv  ".git"  ".."
        else
            git init ${GitInitOption}  > /dev/null  ||  Error
            git config --local user.email "${LocommitEMail}"
            git config --local user.name  "${LocommitUser}"
            git add  "."
            git commit  -m "locommit pull) Created a common commit." > /dev/null  #// Ignore this command errors
            currentBranch=$( git rev-parse --abbrev-ref HEAD  || echo "(ERROR)" )
            ErrorIfLastIs  "${currentBranch}"  "(ERROR)"
            mkdir -p  "../.commit_theirs"
            mv  ".git"  "../.commit_theirs"
        fi

    #// Make the repository branch
        cd  "../.commit_theirs"
        local  reposirotyBranchExists="${False}"
        git branch | grep "__locommit_commit_theirs" > /dev/null 2>&1  &&  reposirotyBranchExists="${True}"
        if [ "${reposirotyBranchExists}" == "${True}" ]; then
            git branch -D "__locommit_commit_theirs" > /dev/null 2>&1  ||  Error
        fi
        git checkout -b "__locommit_commit_theirs" > /dev/null 2>&1  ||  Error
        if [ "${option}" == "--pull-base" ]; then
            rm -rf  "${baseFolderRelativePath}"
        fi
        git add "." > /dev/null
        git commit  -m "locommit pull) commit_theirs" > /dev/null  #// Ignore this command errors
        local  oldCommitID=$( git rev-parse --short "${currentBranch}"  || echo "(ERROR)" )
        local  othersCommitID=$( git rev-parse --short __locommit_commit_theirs  || echo "(ERROR)" )
        ErrorIfLastIs  "${oldCommitID}"  "(ERROR)"
        ErrorIfLastIs  "${othersCommitID}"  "(ERROR)"
        mkdir -p "../.commit_temporary"
        mv  ".git"  "../.commit_temporary"

    #// Change current branch
        cd  "../.commit_temporary"
        git checkout "${currentBranch}" > /dev/null 2>&1  ||  Error
        rm -rf  "../.git"
        mv  ".git"  ".."
        cd  ".."
        mv  ".commit_temporary"  ".commit_temporary_deleting"
        rm -rf  ".commit_temporary_deleting"  #// This command is sometimes rejected because device or resource busy
    popd > /dev/null

    #// Merge
    #// source: ".commit_theirs" folder
    #// destination: current folder
    if [ "${source}" == ".commit_new" ]; then
        git add "."
        git commit  -m "locommit pull) commit_ours" > /dev/null
    fi
    if [ "${othersCommitID}" != "${oldCommitID}" ]; then

        local  mergeLog="$( git merge  "__locommit_commit_theirs" --no-edit  2>&1  ||  echo "(ERROR)" )"
        if echo "${mergeLog}" | grep "Abort."; then
            echo "${mergeLog}"
            Error  "failed: git merge .commit_theirs"
        fi
    fi
    if [ "${parentDotGit}" == "${True}" ]; then
        rm -rf  ".git"
    else
        git branch -D  "__locommit_commit_theirs"  > /dev/null
    fi

    #// Restore .git folder and stage before pull files
    if [ "${othersCommitID}" != "${oldCommitID}" ]; then
        if [ -e ".commit/.git" ]; then
            cd  ".commit_ours"
            mv  "../.commit/.git"  "."
            git add  "."
            cd  ".."
            mv  ".commit_ours/.git"  "."
        fi

        #// Diff
        local  diff_output="$( diff -qr  ".commit"  ".commit_theirs" )"
        if [ "${option}" == "--pull-base" ]; then
            echo  "Renamed \".commit\" folder to \".commit_old_base\" folder"
            echo  "Renamed \".commit_theirs\" folder to new \"${baseFolderPath}\" folder"
            diff_output="$( echo "${diff_output}"  |
                sed -E 's|.commit/|.commit_old_base/|g'  |
                sed -E 's|.commit_theirs/|new _base/|g'  )"
        fi
        ErrorIfLastIs  "${diff_output}"  "(ERROR)"
        if [ "${option}" == "--pull" ]; then
            echo  "Updated files by this merge from \".commit_theirs\" folder:"
        else
            echo  "Updated files by this merge from new \"${baseFolderPath}\" folder:"
        fi
        EchoWithIndent  "${diff_output}"  "    "
    else
        echo  'Renamed ".commit_ours" folder to ".commit_new" folder'
        echo  'Deleted ".commit_theirs" folder'
        echo  'Pull command did not change any files.'
        if [ -e ".commit/.git" ]; then
            mv  ".commit/.git"  "."
        fi
        mv  ".commit_ours"  ".commit_new"
        rm -rf  ".commit_theirs"
    fi
}

function  PullBase() {
    #   *   5 (pulled)
    #   |\
    #   | * 4 _repository
    #   * | 3 .commit_new
    #   * | 2 .commit
    #   |/
    #   *   1 _base
    local  baseFolderPath_=$( ResolvePath "$1"  || echo "(ERROR)" )
    local  repositoryFolderPath_="$2"
    local  baseFolderPath="$( CutLastOf "${baseFolderPath_}" "/"  || echo "(ERROR)" )"
    local  repositoryFolderPath_=$( ResolvePath "${repositoryFolderPath_}"  || echo "(ERROR)" )
    local  repositoryFolderPath="$( CutLastOf "${repositoryFolderPath_}" "/"  || echo "(ERROR)" )"
    ErrorIfLastIs  "${baseFolderPath_}"  "(ERROR)"
    ErrorIfLastIs  "${baseFolderPath}"  "(ERROR)"
    ErrorIfLastIs  "${repositoryFolderPath_}"  "(ERROR)"
    ErrorIfLastIs  "${repositoryFolderPath}"  "(ERROR)"
    if [ "${baseFolderPath}" == "" ]; then
        Error  "Not specified base folder.  Expected command: locommit pull-base __BaseFolderRelativePath__ __RepositoryFolderPath__"
    fi
    if [ "${repositoryFolderPath}" == "" ]; then
        Error  "Not specified repository folder.  Expected command: locommit pull-base __BaseFolderRelativePath__ __RepositoryFolderPath__"
    fi
    if [ "${baseFolderPath:0:2}" == ".."  -o  "${baseFolderPath:0:1}" == "/" ]; then
        Error  "BaseFolderPath must be in current folder."
    fi
    AssertExist  "${baseFolderPath}"
    AssertExist  "${repositoryFolderPath}"

    echo  "Renamed \".commit\" folder to \".commit_this\" folder"
    echo  "Renamed \"${baseFolderPath}\" folder to \".commit\" folder"
    mv  ".commit"  ".commit_this"
    mv  "${baseFolderPath}"  ".commit"

    #// Pull command
    shift
    PullSub  "$1"  --pull-base  "${baseFolderPath}"

    if [ -e ".commit_theirs" ]; then
        #// There is echo command in PullSub
        mv  ".commit"  ".commit_old_base"
        mv  ".commit_theirs"  "${baseFolderPath}"
    else
        echo  "Renamed \".commit\" folder to new \"${baseFolderPath}\" folder"
        mv  ".commit"  "${baseFolderPath}"
    fi
    if [ -e ".commit_ours" ]; then
        echo  "Renamed \".commit_ours\" folder to \".commit_old_ours\" folder"
        mv  ".commit_ours"  ".commit_old_ours"
    fi
    echo  "Renamed \".commit_this\" folder to \".commit\" folder"
    mv  ".commit_this"  ".commit"
}

function  PullFile() {
    local  repositoryFolderPath_="$1"
    local  option="$2"  #// "--pull" or "--pull-base"
    local  baseFolderRelativePath="$3"  #// This is enabled if option == "--pull-base"
    local  fileRelativePath="${Options_File}"
    local  fileName="${fileRelativePath##*/}"
    local  repositoryFolderPath_=$( ResolvePath "${repositoryFolderPath_}"  || echo "(ERROR)" )
    local  repositoryFolderPath="$( CutLastOf "${repositoryFolderPath_}" "/"  || echo "(ERROR)" )"
    ErrorIfLastIs  "${repositoryFolderPath_}"  "(ERROR)"
    ErrorIfLastIs  "${repositoryFolderPath}"  "(ERROR)"
    if [ "${repositoryFolderPath}" == "" ]; then
        Error  "Not specified repository folder.  Expected command: locommit pull __RepositoryFolderPath__"
    fi
    test -f "${repositoryFolderPath}/${fileRelativePath}"  ||  Error
    if [ "${baseFolderRelativePath:0:2}" == ".." ]; then  Error;  fi
    if [ "${baseFolderRelativePath:0:1}" == "/" ]; then  Error;  fi
    AssertExist  "${repositoryFolderPath}"
    AssertExist  ".commit"

    #// Create ".commit_theirs" folder
    local  destination=".commit_theirs/${fileRelativePath}"
    local  destinationParent="${destination%/*}"
    mkdir -p  "${destinationParent}"
    rm -f  ".commit_theirs/${fileRelativePath}"

    cp  "${repositoryFolderPath}/${fileRelativePath}"  ".commit_theirs/${fileRelativePath}"
    chmod 444  ".commit_theirs/${fileRelativePath}"
    echo  "Copied a file in repository folder to \".commit_theirs\" folder"

    #// Create ".commit_ours" folder
    local  destination=".commit_ours/${fileRelativePath}"
    local  destinationParent="${destination%/*}"
    mkdir -p  "${destinationParent}"
    rm -f  ".commit_ours/${fileRelativePath}"

    cp  "${fileRelativePath}"  ".commit_ours/${fileRelativePath}"
    chmod 444  ".commit_ours/${fileRelativePath}"
    echo  "Copied a file in current folder to \".commit_ours\" folder"

    #// Merge
    #// source: ".commit_theirs" folder
    #// destination: current folder
    rm -rf    ".commit_merging"
    mkdir -p  ".commit_merging"
    pushd  ".commit_merging" > /dev/null

        #// Make common commit
        cp  "../.commit/${fileRelativePath}"  "."
        chmod 644  "${fileName}"
        git init ${GitInitOption}  > /dev/null  ||  Error
        git config --local user.email "${LocommitEMail}"
        git config --local user.name  "${LocommitUser}"
        git add  "." > /dev/null
        git commit  -m "locommit pull) Created a common commit." > /dev/null  #// Ignore this command errors
        local  currentBranch=$( git rev-parse --abbrev-ref HEAD  || echo "(ERROR)" )
        ErrorIfLastIs  "${currentBranch}"  "(ERROR)"

        #// Make commit_theirs
        cp  "../.commit_theirs/${fileRelativePath}"  "."
        chmod 644  "${fileName}"
        git checkout -b "__locommit_commit_theirs" > /dev/null 2>&1  ||  Error
        git add "." > /dev/null
        git commit  -m "locommit pull) commit_theirs" > /dev/null  #// Ignore this command errors

        #// Make commit_ours
        git checkout "${currentBranch}" > /dev/null 2>&1  ||  Error
        cp  "../.commit_ours/${fileRelativePath}"  "."
        chmod 644  "${fileName}"
        git checkout -b "__locommit_commit_ours" > /dev/null 2>&1  ||  Error
        git add "." > /dev/null
        git commit  -m "locommit pull) commit_ours" > /dev/null  #// Ignore this command errors

        #// Merge
        local  mergeLog="$( git merge  "__locommit_commit_theirs" --no-edit  2>&1  ||  echo "(ERROR)" )"
        if echo "${mergeLog}" | grep "Abort."; then
            echo "${mergeLog}"
            Error  "failed: git merge .commit_theirs"
        fi
    popd > /dev/null

    cp -ap  ".commit_merging/${fileName}"  "."
    rm -rf  ".commit_merging"
}

function  InitBarePush() {
    local  newRepositoryFolderPath=$( ResolvePath "$1"  || echo "(ERROR)" )
    ErrorIfLastIs  "${newRepositoryFolderPath}"  "(ERROR)"
    if [ "${Options_Branch}" == "" ]; then
        local  branch="$( GetCurrentGitBranch )"
        if [ "${branch}" == "" ]; then
            branch="main"
        fi
    else
        local  branch="${Options_Branch}"
    fi
    if [ "${newRepositoryFolderPath}" == "" ]; then
        Error  "Not specified new repository folder.  Expected command: locommit init-bare-push __NewRepositoryFolderPath__"
    fi
    if [ -e ".git" ]; then
        local  dotGitExistsInCurrentFolder="${True}"
    else
        local  dotGitExistsInCurrentFolder="${False}"
    fi
    AssertNotExist  "${newRepositoryFolderPath}"
    local  currentFolder="${PWD}"
    if [ "${dotGitExistsInCurrentFolder}" == "${False}" ]; then
        git init ${GitInitOption}  > /dev/null  2>&1
        git config --local user.email "${LocommitEMail}"
        git config --local user.name  "${LocommitUser}"
        git add "."  > /dev/null  2>&1
        git commit  -m "locommit) Created by InitBarePush"  > /dev/null  2>&1
        local  allFilesAreGitAdd="${True}"
    else
        CheckIfGitResetState
        if AllFilesAreGitAdd; then
            local  allFilesAreGitAdd="${True}"
        else
            local  allFilesAreGitAdd="${False}"
        fi
        git add "."  > /dev/null  2>&1
    fi

    #// Copy files
    mkdir -p ".commit_init-bare-push"

    git checkout-index -fau --prefix=".commit_init-bare-push/"

    #// Create new repository
    mkdir -p "${newRepositoryFolderPath}"
    pushd  "${newRepositoryFolderPath}"  >  /dev/null
    local  newRepositoryFullPath="${PWD}"

    git init --bare --shared=true
    git symbolic-ref HEAD refs/heads/${branch}
    popd  >  /dev/null

    #// Make a commit
    pushd  ".commit_init-bare-push"  >  /dev/null

    git init ${GitInitOption}  > /dev/null  2>&1
    git remote add origin "file://${newRepositoryFullPath}"
    git checkout -b "${branch}"
    git add "."  > /dev/null  2>&1

    git commit  -m "locommit) Created a local repository"  > /dev/null  2>&1
    git symbolic-ref HEAD refs/heads/${branch}
    git push --set-upstream origin ${branch}
    popd  >  /dev/null

    #// Clean
    git status  > /dev/null  #// Change directory in git process(?) for deleting Windows folder
    if [ "${dotGitExistsInCurrentFolder}" == "${False}" ]; then
        rm -rf "${currentFolder}/.git"
    fi
    DeleteFolder  ".commit_init-bare-push"
    AssertNotExist  ".commit_init-bare-push"
    echo  "Removed \".commit_init-bare-push\" temporary folder."
    if [ "${allFilesAreGitAdd}" == "${False}" ]; then
        git reset  > /dev/null  2>&1
    fi
}

function  AllFilesAreGitAdd() {
    local  status="$( git status --short )"

    if [ "${status}" == "" ]; then
        return  "${False}"
    else
        echo  "${status}" | grep -E '^ [^ ]' > /dev/null;
        test "$?" != 0
        return  $?
    fi
}

function  CheckIfGitResetState() {
    local  status="$( git status --short )"

    #// Error, if one or more files are git added
    # M  edit.txt    ... after git add ... Error
    #  M edit.txt    ... before git add ... OK
    # M  ../edit.txt ... after git add but out of folder ... OK
    # M  .hidden.txt ... not out of folder ... Error
    # ?? new.txt     ... untracked ... OK
    if echo  "${status}"  |  grep -E '^[^ ?]. .[^.]' > /dev/null; then

        #// Error, if one or more files are not git added
        # M  edit.txt    ... after git add ... OK
        #  M edit.txt    ... before git add ... Error
        #  M ../edit.txt ... after git add but out of folder ... OK
        #  M .hidden.txt ... not out of folder ... Error
        # ?? new.txt     ... untracked ... Error
        if echo  "${status}"  |  grep -E '^.[^ ] .[^.]' > /dev/null; then
            echo  '$ git status --short'
            echo  "${status}"
            Error  'ERROR: this command does not supported, when files were git added. You can clone, if you run git reset ".".'
        fi
    fi
}

function  Test_CheckIfGitResetState() {

    #// Error, if one or more files are git added
    echo 'M  edit.txt'    | grep -E '^[^ ?]. .[^.]'  ||  Error
    echo ' M edit.txt'    | grep -E '^[^ ?]. .[^.]'  &&  Error
    echo 'M  ../edit.txt' | grep -E '^[^ ?]. .[^.]'  &&  Error
    echo 'M  .hidden.txt' | grep -E '^[^ ?]. .[^.]'  ||  Error
    echo '?? new.txt'     | grep -E '^[^ ?]. .[^.]'  &&  Error
        # &&: Error if match ... CheckIfGitResetState is successed.
        # ||: Error if not match ... CheckIfGitResetState raises an error.

    #// Error, if one or more files are not git added
    echo 'M  edit.txt'    | grep -E '^.[^ ] .[^.]'  &&  Error
    echo ' M edit.txt'    | grep -E '^.[^ ] .[^.]'  ||  Error
    echo ' M ../edit.txt' | grep -E '^.[^ ] .[^.]'  &&  Error
    echo ' M .hidden.txt' | grep -E '^.[^ ] .[^.]'  ||  Error
    echo '?? new.txt'     | grep -E '^.[^ ] .[^.]'  ||  Error
        # &&: Error if match ... CheckIfGitResetState is successed.
        # ||: Error if not match ... CheckIfGitResetState raises an error.
}

function  EchoWithIndent() {
    local  message="$1"
    local  indent="$2"
    local  oldIFS="$IFS"

    IFS=$'\n'
    for  line  in ${message}; do
        echo "${indent}${line}"
    done
    IFS="$oldIFS"
}

function  ResolvePath() {
    local  path_="$1"

    path_="$( echo "${path_}" | sed -e 's/\\/\//g' | sed -e 's/^C:/c:/'  || echo "(ERROR)" )"  #// replace to / and c:
    ErrorIfLastIs  "${path_}"  "(ERROR)"

    if [ "${mnt_c}" == "" ]; then
        export  mnt_c="/mnt/c";  if [ ! -e "/mnt/c" ]; then  export  mnt_c="c:"  ;fi
    fi
    if [ "${path_:0:3}" == "c:/"  -o  "${path_:0:3}" == "/c/" ]; then
        path_="${mnt_c}/${path_:3}"
    elif [ "${path_:0:7}" == "/mnt/c/" ]; then
        path_="${mnt_c}/${path_:7}"
    fi

    echo  "${path_}"
}

function  GetGitWorkingRootPath() {
    local  path="${PWD}"
    while [ "${path}" != "" ]; do

        if [ -e "${path}/.git" ]; then
            echo  "${path}"
            return
        fi
        path="${path%/*}"
    done

    echo  ""
}

function  GetCurrentGitBranch() {
    git rev-parse --abbrev-ref HEAD
}

function  GetRelativePath() {
    local  fullPath="$1"
    local  basePath="$2"

    local  relativePath=$( echo "$fullPath" | sed -e "s%^${basePath}/%%"  || echo "(ERROR)" )
    ErrorIfLastIs  "${relativePath}"  "(ERROR)"
    echo  "${relativePath}"
}

function  CopyFolder() {
    local  source="$1"
    local  destination="$2"
    local  ignoreDotGit="$3"  #// ${True}, ${False}(default)
    local  excludeOption="--exclude=./.git"
    source="$( CutLastOf  "${source}"  "/"  || echo "(ERROR)" )"
    destination="$( CutLastOf  "${destination}"  "/"  || echo "(ERROR)" )"
    ErrorIfLastIs  "${source}"  "(ERROR)"
    ErrorIfLastIs  "${destination}"  "(ERROR)"
    if [ "${ignoreDotGit}" != ""  -a  "${ignoreDotGit}" != "${excludeOption}" ]; then
        Error  "Bad option: ${ignoreDotGit}"
        return  "${False}"
    fi

    mkdir -p  "${destination}/"
    if [ "${ignoreDotGit}" == "${excludeOption}" ]; then
        ls -a "${source}" | grep -v  -e "^\.git$"  -e "^\.$"  -e "^\.\.$" | xargs  -I {} \
            cp -Rap  "${source}/{}"  "${destination}/"
    else
        ls -a "${source}" | grep -v  -e "^\.$"  -e "^\.\.$" | xargs  -I {} \
            cp -Rap  "${source}/{}"  "${destination}/"
    fi
}

function  DeleteFolder() {
    local  folderPath="$1"
    local  retryCount=5

    while true; do
        rm -rf  "${folderPath}"
        if [ "$?" == "${True}" ]; then
            return
        fi
        retryCount="$(( ${retryCount} - 1 ))"
        if [ "${retryCount}" == "0" ]; then
            Error  "Cannot delete a folder \"${folderPath}\""
        fi
        sleep 2s
    done
}

function  CutCommonPartLines() {
    local  targetLines="$1"
    local  cuttingPartLines="$2"

    #// targetLines - cuttingPartLines
    if [ "${cuttingPartLines}" == "" ]; then
        echo  "${targetLines}"  #// Because "grep -vFf /dev/null" returns empty
    else
        echo  "${targetLines}"  |  grep -vFf <( echo "${cuttingPartLines}" )
    fi

    #// If a cutting line contains in a part of target line, cut the target line.
    #// Example:
    #//     targetLines:
    #//         ab
    #//         cd
    #//         ef
    #//     cuttingPartLines:
    #//         c
    #//     return:
    #//         ab
    #//         ef
}

#// StartsWith
#//     e.g.) if StartsWith  ${wholeString} ${partString}; then
function  StartsWith() {
    local  wholeString="$1"
    local  partString="$2"
    local  partLength=${#partString}

    #// Set exit code
    [ "${wholeString:0:${partLength}}" == "${partString}" ]
}

function  CutLastOf() {
    local  wholeString="$1"
    local  lastExpected="$2"

    if [ "${wholeString:${#wholeString}-${#lastExpected}:${#lastExpected}}" == "${lastExpected}" ]; then
        echo  "${wholeString:0:${#wholeString}-${#lastExpected}}"
    else
        echo  "${wholeString}"
    fi
}

function  gitInitOption() {
    if [ "$( LessThanVersion "$(git --version)" "2.31.1")" == "${True}" ]; then
        echo  ""
    else
        echo  "-bmain"  #// "-b main" occurs an error in bash debug
    fi
}

# LessThanVersion
#     if [ "$( LessThanVersion "$(git --version)" "2.31.1")" == "${True}" ]; then
function  LessThanVersion() {
    local  textContainsVersionA="$1"
    local  textContainsVersionB="$2"
    local  isGoodFormat="${True}"
    echo "${textContainsVersionA}" | grep -e "[0-9]\+\.[0-9]\+\.[0-9]\+" > /dev/null  ||  isGoodFormat="${False}"
    echo "${textContainsVersionB}" | grep -e "[0-9]\+\.[0-9]\+\.[0-9]\+" > /dev/null  ||  isGoodFormat="${False}"
    if [ "${isGoodFormat}" == "${False}" ]; then
        Error  "\"${textContainsVersionA}\" or \"${textContainsVersionB}\" is not semantic version."
    fi

    local  numbersA=( $( echo "${textContainsVersionA}" | grep -o -e "[0-9]\+" ) )
    local  numbersB=( $( echo "${textContainsVersionB}" | grep -o -e "[0-9]\+" ) )
    if [ "${numbersA[0]}" -lt "${numbersB[0]}" ]; then
        echo "${True}"
        return
    elif [ "${numbersA[0]}" == "${numbersB[0]}" ]; then
        if [ "${numbersA[1]}" -lt "${numbersB[1]}" ]; then
            echo "${True}"
            return
        elif [ "${numbersA[1]}" == "${numbersB[1]}" ]; then
            if [ "${numbersA[2]}" -lt "${numbersB[2]}" ]; then
                echo "${True}"
                return
            fi
        fi
    fi
    echo "${False}"
}

function  AssertExist() {
    local  path="$1"

    if [ ! -e "${path}" ]; then
        Error  "Not found \"${path}\""
    fi
}

function  AssertNotExist() {
    local  path="$1"

    if [ -e "${path}" ]; then
        Error  "Found \"${path}\""
    fi
}

function  AssertInstalled() {
    local  checkingCommand="$1"
    local  exists=${False}
    which "${checkingCommand}" > /dev/null  &&  exists=${True}

    if [ "${exists}" == ${False} ]; then
        Error  "Not installed \"${checkingCommand}\" command"
    fi
}

#// pp "$config"
#// pp "$config" config
#// pp "$array" array  ${#array[@]}  "${array[@]}"
#// $( pp "$config" >&2 )
function  pp() {
    local  value="$1"
    local  variableName="$2"
    if [ "${variableName}" != "" ]; then  variableName=" ${variableName} "  ;fi
    local  oldIFS="$IFS"
    IFS=$'\n'
    local  valueLines=( ${value} )
    IFS="$oldIFS"
    if [[ "$(declare -p ${variableName})" =~ "declare -a" ]]; then
        local  type="array"
    elif [ "${#valueLines[@]}" == 1  -o  "${#valueLines[@]}" == 0 ]; then
        local  type="oneLine"
    else
        local  type="multiLine"
    fi

    if [[ "${type}" == "oneLine" ]]; then
        echo  "@@@${variableName}= \"${value}\" ---------------------------"
    elif [[ "${type}" == "multiLine" ]]; then
        echo  "@@@${variableName}---------------------------"
        echo  "\"${value}\""
    elif [[ "${type}" == "array" ]]; then
        echo  "@@@${variableName}---------------------------"
        local  count="$3"
        if [ "${count}" == "" ]; then
            echo  "[0]: \"$4\""
            echo  "[1]: ERROR: pp parameter is too few"
        else
            local  i="0"
            for (( i = 0; i < ${count}; i += 1 ));do
                echo  "[$i]: \"$4\""
                shift
            done
        fi
    else
        echo  "@@@${variableName}? ---------------------------"
    fi
}

# EndsWith
#    if EndsWith "abc" "bc"; then
function  EndsWith() {
    local  output="$1"
    local  tag="$2"

    local  last="${output:${#output}-${#tag}:${#tag}}"

    if [ "${last}" == "${tag}" ]; then
        return  "${True}"
    else
        return  "${False}"
    fi
}

# ErrorIfLastIs
#     Error check in $( )
#     variable="$( command  || echo "(ERROR)" )"
#     ErrorIfLastIs  "${output}"  "(ERROR)"
function  ErrorIfLastIs() {
    local  output="$1"
    local  tag="$2"

    local  last="${output:${#output}-${#tag}:${#tag}}"

    if [ "${last}" == "${tag}" ]; then
        exit  2
    fi
}

function  Error() {
    local  errorMessage="$1"
    local  exitCode="$2"
    if [ "${errorMessage}" == "" ]; then
        errorMessage="ERROR"
    fi
    if [ "${exitCode}" == "" ]; then  exitCode=2  ;fi

    echo  "${errorMessage}" >&2
    exit  "${exitCode}"
}

True=0
False=1
GitInitOption=$(gitInitOption)
LocommitEMail="locommit@example.com"
LocommitUser="locommit"

Main  "$@"
